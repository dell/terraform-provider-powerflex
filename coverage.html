
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>powerflex: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">terraform-provider-powerflex/powerflex/helper.go (71.4%)</option>
				
				<option value="file1">terraform-provider-powerflex/powerflex/protection_domain_datasource.go (80.5%)</option>
				
				<option value="file2">terraform-provider-powerflex/powerflex/protection_domain_datasource_schema.go (100.0%)</option>
				
				<option value="file3">terraform-provider-powerflex/powerflex/provider.go (77.0%)</option>
				
				<option value="file4">terraform-provider-powerflex/powerflex/sdc_datasource.go (77.8%)</option>
				
				<option value="file5">terraform-provider-powerflex/powerflex/sdc_helper.go (100.0%)</option>
				
				<option value="file6">terraform-provider-powerflex/powerflex/sdc_resource.go (73.7%)</option>
				
				<option value="file7">terraform-provider-powerflex/powerflex/sds_resource.go (75.2%)</option>
				
				<option value="file8">terraform-provider-powerflex/powerflex/snapshotpolicy_datasource.go (94.3%)</option>
				
				<option value="file9">terraform-provider-powerflex/powerflex/storagepool_data_source.go (86.2%)</option>
				
				<option value="file10">terraform-provider-powerflex/powerflex/storagepool_resource.go (79.5%)</option>
				
				<option value="file11">terraform-provider-powerflex/powerflex/volume_datasource.go (84.3%)</option>
				
				<option value="file12">terraform-provider-powerflex/powerflex/volume_resource.go (12.2%)</option>
				
				<option value="file13">terraform-provider-powerflex/powerflex/volume_resource_helper.go (22.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package powerflex

import (
        "fmt"

        "github.com/dell/goscaleio"
)

// getFirstSystem - finds available first system and returns it.
func getFirstSystem(rc *goscaleio.Client) (*goscaleio.System, error) <span class="cov8" title="1">{
        allSystems, err := rc.GetSystems()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error in goscaleio GetSystems")
        }</span>
        <span class="cov8" title="1">system, err := rc.FindSystem(allSystems[0].ID, "", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error in goscaleio FindSystem")
        }</span>
        <span class="cov8" title="1">return system, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package powerflex

import (
        "context"

        "terraform-provider-powerflex/helper"

        "github.com/dell/goscaleio"
        scaleiotypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
        _ datasource.DataSource              = &amp;protectionDomainDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;protectionDomainDataSource{}
)

// ProtectionDomainDataSource returns the datasource for protection domain
func ProtectionDomainDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;protectionDomainDataSource{}
}</span>

type protectionDomainDataSource struct {
        client *goscaleio.Client
}

type protectionDomainDataSourceModel struct {
        ProtectionDomains []protectionDomainModel `tfsdk:"protection_domains"`
        ID                types.String            `tfsdk:"id"`
        Name              types.String            `tfsdk:"name"`
}

type protectionDomainModel struct {
        SystemID                    types.String    `tfsdk:"system_id"`
        SdrSdsConnectivityInfo      pdConnInfoModel `tfsdk:"sdr_sds_connectivity"`
        ReplicationCapacityMaxRatio types.Int64     `tfsdk:"replication_capacity_max_ratio"`

        // Network throttling params
        RebuildNetworkThrottlingInKbps                   types.Int64 `tfsdk:"rebuild_network_throttling_in_kbps"`
        RebalanceNetworkThrottlingInKbps                 types.Int64 `tfsdk:"rebalance_network_throttling_in_kbps"`
        OverallIoNetworkThrottlingInKbps                 types.Int64 `tfsdk:"overall_io_network_throttling_in_kbps"`
        VTreeMigrationNetworkThrottlingInKbps            types.Int64 `tfsdk:"vtree_migration_network_throttling_in_kbps"`
        ProtectedMaintenanceModeNetworkThrottlingInKbps  types.Int64 `tfsdk:"protected_maintenance_mode_network_throttling_in_kbps"`
        OverallIoNetworkThrottlingEnabled                types.Bool  `tfsdk:"overall_io_network_throttling_enabled"`
        RebuildNetworkThrottlingEnabled                  types.Bool  `tfsdk:"rebuild_network_throttling_enabled"`
        RebalanceNetworkThrottlingEnabled                types.Bool  `tfsdk:"rebalance_network_throttling_enabled"`
        VTreeMigrationNetworkThrottlingEnabled           types.Bool  `tfsdk:"vtree_migration_network_throttling_enabled"`
        ProtectedMaintenanceModeNetworkThrottlingEnabled types.Bool  `tfsdk:"protected_maintenance_mode_network_throttling_enabled"`

        // Fine Granularity Params
        FglDefaultNumConcurrentWrites types.Int64 `tfsdk:"fgl_default_num_concurrent_writes"`
        FglMetadataCacheEnabled       types.Bool  `tfsdk:"fgl_metadata_cache_enabled"`
        FglDefaultMetadataCacheSize   types.Int64 `tfsdk:"fgl_default_metadata_cache_size"`

        // RfCache Params
        RfCacheEnabled         types.Bool   `tfsdk:"rf_cache_enabled"`
        RfCacheAccpID          types.String `tfsdk:"rf_cache_accp_id"`
        RfCacheOperationalMode types.String `tfsdk:"rf_cache_opertional_mode"`
        RfCachePageSizeKb      types.Int64  `tfsdk:"rf_cache_page_size_kb"`
        RfCacheMaxIoSizeKb     types.Int64  `tfsdk:"rf_cache_max_io_size_kb"`

        // Counter Params
        SdsConfigurationFailureCP            pdCounterModel `tfsdk:"sds_configuration_failure_counter"`
        SdsDecoupledCP                       pdCounterModel `tfsdk:"sds_decoupled_counter"`
        MdmSdsNetworkDisconnectionsCP        pdCounterModel `tfsdk:"mdm_sds_network_disconnections_counter"`
        SdsSdsNetworkDisconnectionsCP        pdCounterModel `tfsdk:"sds_sds_network_disconnections_counter"`
        SdsReceiveBufferAllocationFailuresCP pdCounterModel `tfsdk:"sds_receive_buffer_allocation_failures_counter"`

        State types.String                `tfsdk:"state"`
        Name  types.String                `tfsdk:"name"`
        ID    types.String                `tfsdk:"id"`
        Links []protectionDomainLinkModel `tfsdk:"links"`
}

type windowModel struct {
        Threshold       types.Int64 `tfsdk:"threshold"`
        WindowSizeInSec types.Int64 `tfsdk:"window_size_in_sec"`
}

type pdCounterModel struct {
        ShortWindow  windowModel `tfsdk:"short_window"`
        MediumWindow windowModel `tfsdk:"medium_window"`
        LongWindow   windowModel `tfsdk:"long_window"`
}

func pdCounterModelValue(p scaleiotypes.PDCounterParams) pdCounterModel <span class="cov8" title="1">{
        return pdCounterModel{
                ShortWindow: windowModel{
                        Threshold:       types.Int64Value(int64(p.ShortWindow.Threshold)),
                        WindowSizeInSec: types.Int64Value(int64(p.ShortWindow.WindowSizeInSec)),
                },
                MediumWindow: windowModel{
                        Threshold:       types.Int64Value(int64(p.MediumWindow.Threshold)),
                        WindowSizeInSec: types.Int64Value(int64(p.MediumWindow.WindowSizeInSec)),
                },
                LongWindow: windowModel{
                        Threshold:       types.Int64Value(int64(p.LongWindow.Threshold)),
                        WindowSizeInSec: types.Int64Value(int64(p.LongWindow.WindowSizeInSec)),
                },
        }
}</span>

type pdConnInfoModel struct {
        ClientServerConnStatus types.String `tfsdk:"client_server_conn_status"`
        DisconnectedClientID   types.String `tfsdk:"disconnected_client_id"`
        DisconnectedClientName types.String `tfsdk:"disconnected_client_name"`
        DisconnectedServerID   types.String `tfsdk:"disconnected_server_id"`
        DisconnectedServerName types.String `tfsdk:"disconnected_server_name"`
        DisconnectedServerIP   types.String `tfsdk:"disconnected_server_ip"`
}

func pdConnInfoModelValue(p scaleiotypes.PDConnInfo) pdConnInfoModel <span class="cov8" title="1">{
        pdconninfo := pdConnInfoModel{
                ClientServerConnStatus: types.StringValue(p.ClientServerConnStatus),
        }
        if v := p.DisconnectedClientID; v != nil </span><span class="cov8" title="1">{
                pdconninfo.DisconnectedClientID = types.StringValue(*v)
        }</span> else<span class="cov8" title="1"> {
                pdconninfo.DisconnectedClientID = types.StringNull()
        }</span>
        <span class="cov8" title="1">if v := p.DisconnectedClientName; v != nil </span><span class="cov8" title="1">{
                pdconninfo.DisconnectedClientName = types.StringValue(*v)
        }</span> else<span class="cov8" title="1"> {
                pdconninfo.DisconnectedClientName = types.StringNull()
        }</span>
        <span class="cov8" title="1">if v := p.DisconnectedServerID; v != nil </span><span class="cov8" title="1">{
                pdconninfo.DisconnectedServerID = types.StringValue(*v)
        }</span> else<span class="cov8" title="1"> {
                pdconninfo.DisconnectedServerID = types.StringNull()
        }</span>
        <span class="cov8" title="1">if v := p.DisconnectedServerName; v != nil </span><span class="cov8" title="1">{
                pdconninfo.DisconnectedServerName = types.StringValue(*v)
        }</span> else<span class="cov8" title="1"> {
                pdconninfo.DisconnectedServerName = types.StringNull()
        }</span>
        <span class="cov8" title="1">if v := p.DisconnectedServerIP; v != nil </span><span class="cov8" title="1">{
                pdconninfo.DisconnectedServerIP = types.StringValue(*v)
        }</span> else<span class="cov8" title="1"> {
                pdconninfo.DisconnectedServerIP = types.StringNull()
        }</span>
        <span class="cov8" title="1">return pdconninfo</span>
}

type protectionDomainLinkModel struct {
        Rel  types.String `tfsdk:"rel"`
        HREF types.String `tfsdk:"href"`
}

func (d *protectionDomainDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_protection_domain"
}</span>

func (d *protectionDomainDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = ProtectionDomainDataSourceSchema
}</span>

func (d *protectionDomainDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">d.client = req.ProviderData.(*goscaleio.Client)</span>
}

func (d *protectionDomainDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var state protectionDomainDataSourceModel
        var err error

        diags := req.Config.Get(ctx, &amp;state)
        tflog.Info(ctx, "[POWERFLEX] protectionDomainDataSourceModel"+helper.PrettyJSON((state)))

        systems, err := d.client.GetSystems()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex Systems",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">if numSys := len((systems)); numSys == 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("No systems found", "")
                return
        }</span> else<span class="cov8" title="1"> if numSys &gt; 1 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("More than one system found", "")
                return
        }</span>
        <span class="cov8" title="1">system, err := d.client.FindSystem(systems[0].ID, "", "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex Protection Domains",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">var protectionDomains []*scaleiotypes.ProtectionDomain

        if !state.ID.IsNull() </span><span class="cov8" title="1">{
                // Fetch protection domain of given id
                var protectionDomain *scaleiotypes.ProtectionDomain
                protectionDomain, err = system.FindProtectionDomain(state.ID.ValueString(), "", "")
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to Read Powerflex ProtectionDomain by ID",
                                err.Error(),
                        )
                        return
                }</span>
                <span class="cov8" title="1">protectionDomains = append(protectionDomains, protectionDomain)</span>
        } else<span class="cov8" title="1"> if !state.Name.IsNull() </span><span class="cov8" title="1">{
                // Fetch protection domain of given name
                var protectionDomain *scaleiotypes.ProtectionDomain
                protectionDomain, err = system.FindProtectionDomain("", state.Name.ValueString(), "")
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to Read Powerflex ProtectionDomain by name",
                                err.Error(),
                        )
                        return
                }</span>
                <span class="cov8" title="1">protectionDomains = append(protectionDomains, protectionDomain)
                // this is required for acceptance testing
                state.ID = types.StringValue(protectionDomain.ID)</span>
        } else<span class="cov8" title="1"> {
                // Fetch all protection domains
                protectionDomains, err = system.GetProtectionDomain("")
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to Read Powerflex ProtectionDomains",
                                err.Error(),
                        )
                        return
                }</span>
                // this is required for acceptance testing
                <span class="cov8" title="1">state.ID = types.StringValue("DummyID")</span>
        }

        <span class="cov8" title="1">state.ProtectionDomains = getAllProtectionDomainState(protectionDomains)

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

func getAllProtectionDomainState(protectionDomains []*scaleiotypes.ProtectionDomain) (response []protectionDomainModel) <span class="cov8" title="1">{
        for _, protectionDomainValue := range protectionDomains </span><span class="cov8" title="1">{
                protectionDomainState := protectionDomainModel{
                        SystemID:               types.StringValue(protectionDomainValue.SystemID),
                        SdrSdsConnectivityInfo: pdConnInfoModelValue(protectionDomainValue.SdrSdsConnectivityInfo),

                        // Network throttling params
                        RebuildNetworkThrottlingInKbps:                   types.Int64Value(int64(protectionDomainValue.RebuildNetworkThrottlingInKbps)),
                        RebalanceNetworkThrottlingInKbps:                 types.Int64Value(int64(protectionDomainValue.RebalanceNetworkThrottlingInKbps)),
                        OverallIoNetworkThrottlingInKbps:                 types.Int64Value(int64(protectionDomainValue.OverallIoNetworkThrottlingInKbps)),
                        VTreeMigrationNetworkThrottlingInKbps:            types.Int64Value(int64(protectionDomainValue.VTreeMigrationNetworkThrottlingInKbps)),
                        ProtectedMaintenanceModeNetworkThrottlingInKbps:  types.Int64Value(int64(protectionDomainValue.ProtectedMaintenanceModeNetworkThrottlingInKbps)),
                        OverallIoNetworkThrottlingEnabled:                types.BoolValue(protectionDomainValue.OverallIoNetworkThrottlingEnabled),
                        RebuildNetworkThrottlingEnabled:                  types.BoolValue(protectionDomainValue.RebuildNetworkThrottlingEnabled),
                        RebalanceNetworkThrottlingEnabled:                types.BoolValue(protectionDomainValue.RebalanceNetworkThrottlingEnabled),
                        VTreeMigrationNetworkThrottlingEnabled:           types.BoolValue(protectionDomainValue.VTreeMigrationNetworkThrottlingEnabled),
                        ProtectedMaintenanceModeNetworkThrottlingEnabled: types.BoolValue(protectionDomainValue.ProtectedMaintenanceModeNetworkThrottlingEnabled),

                        // Fine Granularity Params
                        FglDefaultNumConcurrentWrites: types.Int64Value(int64(protectionDomainValue.FglDefaultNumConcurrentWrites)),
                        FglMetadataCacheEnabled:       types.BoolValue(protectionDomainValue.FglMetadataCacheEnabled),
                        FglDefaultMetadataCacheSize:   types.Int64Value(int64(protectionDomainValue.FglDefaultMetadataCacheSize)),

                        // RfCache Params
                        RfCacheEnabled:         types.BoolValue(protectionDomainValue.RfCacheEnabled),
                        RfCacheAccpID:          types.StringValue(protectionDomainValue.RfCacheAccpID),
                        RfCacheOperationalMode: types.StringValue(string(protectionDomainValue.RfCacheOperationalMode)),
                        RfCachePageSizeKb:      types.Int64Value(int64(protectionDomainValue.RfCachePageSizeKb)),
                        RfCacheMaxIoSizeKb:     types.Int64Value(int64(protectionDomainValue.RfCacheMaxIoSizeKb)),

                        // Counter Params
                        SdsConfigurationFailureCP:            pdCounterModelValue(protectionDomainValue.SdsConfigurationFailureCP),
                        SdsDecoupledCP:                       pdCounterModelValue(protectionDomainValue.SdsDecoupledCP),
                        MdmSdsNetworkDisconnectionsCP:        pdCounterModelValue(protectionDomainValue.MdmSdsNetworkDisconnectionsCP),
                        SdsSdsNetworkDisconnectionsCP:        pdCounterModelValue(protectionDomainValue.SdsSdsNetworkDisconnectionsCP),
                        SdsReceiveBufferAllocationFailuresCP: pdCounterModelValue(protectionDomainValue.SdsReceiveBufferAllocationFailuresCP),

                        State: types.StringValue(protectionDomainValue.ProtectionDomainState),
                        Name:  types.StringValue(protectionDomainValue.Name),
                        ID:    types.StringValue(protectionDomainValue.ID),
                }

                if v := protectionDomainValue.ReplicationCapacityMaxRatio; v != nil </span><span class="cov8" title="1">{
                        protectionDomainState.ReplicationCapacityMaxRatio = types.Int64Value(int64(*v))
                }</span> else<span class="cov8" title="1"> {
                        protectionDomainState.ReplicationCapacityMaxRatio = types.Int64Null()
                }</span>

                <span class="cov8" title="1">for _, link := range protectionDomainValue.Links </span><span class="cov8" title="1">{
                        protectionDomainState.Links = append(protectionDomainState.Links, protectionDomainLinkModel{
                                Rel:  types.StringValue(link.Rel),
                                HREF: types.StringValue(link.HREF),
                        })
                }</span>

                <span class="cov8" title="1">response = append(response, protectionDomainState)</span>
        }

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package powerflex

import (
        "github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
        "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/schema/validator"
)

// ProtectionDomainDataSourceSchema defines the schema for Protection Domain datasource
var ProtectionDomainDataSourceSchema schema.Schema = schema.Schema{
        Description:         "Datasource for powerflex manager protection domains.",
        MarkdownDescription: "Datasource for powerflex manager protection domains.",
        Attributes: map[string]schema.Attribute{
                "id": schema.StringAttribute{
                        Description:         "Unique identifier of the protection domain instance.",
                        MarkdownDescription: "Unique identifier of the protection domain instance.",
                        Optional:            true,
                },
                "name": schema.StringAttribute{
                        Description:         "Unique name of the protection domain instance.",
                        MarkdownDescription: "Unique name of the protection domain instance.",
                        Optional:            true,
                        Validators: []validator.String{
                                stringvalidator.ConflictsWith(path.MatchRoot("id")),
                        },
                },
                "protection_domains": schema.ListNestedAttribute{
                        Description:         "List of protection domains fetched.",
                        MarkdownDescription: "List of protection domains fetched.",
                        Computed:            true,
                        NestedObject: schema.NestedAttributeObject{
                                Attributes: protectionDomainDataAttributes,
                        },
                },
        },
}

var protectionDomainDataAttributes map[string]schema.Attribute = map[string]schema.Attribute{
        "id": schema.StringAttribute{
                Description:         "Unique identifier of the protection domain instance.",
                MarkdownDescription: "Unique identifier of the protection domain instance.",
                Computed:            true,
        },
        "name": schema.StringAttribute{
                Description:         "Unique name of the protection domain instance.",
                MarkdownDescription: "Unique name of the protection domain instance.",
                Computed:            true,
        },
        "state": schema.StringAttribute{
                Description:         "State of a PD, which can be Active, ActivePending, Inactive or InactivePending.",
                MarkdownDescription: "State of a PD, which can be Active, ActivePending, Inactive or InactivePending.",
                Computed:            true,
        },
        "system_id": schema.StringAttribute{
                Description:         "System ID of the PD.",
                MarkdownDescription: "System ID of the PD.",
                Computed:            true,
        },
        "rf_cache_accp_id": schema.StringAttribute{
                Description:         "Rf Cache  Acceleration Pool ID.",
                MarkdownDescription: "Rf Cache  Acceleration Pool ID.",
                Computed:            true,
        },
        "rf_cache_enabled": schema.BoolAttribute{
                Description:         "Whether SDS Rf Cache is enabled or not.",
                MarkdownDescription: "Whether SDS Rf Cache is enabled or not.",
                Computed:            true,
        },
        "rf_cache_opertional_mode": schema.StringAttribute{
                Description:         "Operational Mode of the SDS RF Cache.",
                MarkdownDescription: "Operational Mode of the SDS RF Cache.",
                Computed:            true,
        },
        "rf_cache_page_size_kb": schema.Int64Attribute{
                Description:         "Page size of the SDS RF Cache in KB.",
                MarkdownDescription: "Page size of the SDS RF Cache in KB.",
                Computed:            true,
        },
        "rf_cache_max_io_size_kb": schema.Int64Attribute{
                Description:         "Maximum io of the SDS RF Cache in KB.",
                MarkdownDescription: "Maximum io of the SDS RF Cache in KB.",
                Computed:            true,
        },
        "fgl_default_num_concurrent_writes": schema.Int64Attribute{
                Description:         "Fine Granularity default number of concurrent writes.",
                MarkdownDescription: "Fine Granularity default number of concurrent writes.",
                Computed:            true,
        },
        "fgl_metadata_cache_enabled": schema.BoolAttribute{
                Description:         "Whether Fine Granularity Metadata Cache is enabled or not.",
                MarkdownDescription: "Whether Fine Granularity Metadata Cache is enabled or not.",
                Computed:            true,
        },
        "fgl_default_metadata_cache_size": schema.Int64Attribute{
                Description:         "Fine Granularity Metadata Cache size.",
                MarkdownDescription: "Fine Granularity Metadata Cache size.",
                Computed:            true,
        },
        "protected_maintenance_mode_network_throttling_enabled": schema.BoolAttribute{
                Description:         "Whether network throttling is enabled for protected maintenance mode.",
                MarkdownDescription: "Whether network throttling is enabled for protected maintenance mode.",
                Computed:            true,
        },
        "protected_maintenance_mode_network_throttling_in_kbps": schema.Int64Attribute{
                Description:         "Maximum allowed io for protected maintenance mode in KBps.",
                MarkdownDescription: "Maximum allowed io for protected maintenance mode in KBps.",
                Computed:            true,
        },
        "rebuild_network_throttling_enabled": schema.BoolAttribute{
                Description:         "Whether network throttling is enabled for rebuilding.",
                MarkdownDescription: "Whether network throttling is enabled for rebuilding.",
                Computed:            true,
        },
        "rebuild_network_throttling_in_kbps": schema.Int64Attribute{
                Description:         "Maximum allowed io for rebuilding in KBps.",
                MarkdownDescription: "Maximum allowed io for rebuilding in KBps.",
                Computed:            true,
        },
        "rebalance_network_throttling_enabled": schema.BoolAttribute{
                Description:         "Whether network throttling is enabled for rebalancing.",
                MarkdownDescription: "Whether network throttling is enabled for rebalancing.",
                Computed:            true,
        },
        "rebalance_network_throttling_in_kbps": schema.Int64Attribute{
                Description:         "Maximum allowed io for rebalancing in KBps.",
                MarkdownDescription: "Maximum allowed io for rebalancing in KBps.",
                Computed:            true,
        },
        "vtree_migration_network_throttling_enabled": schema.BoolAttribute{
                Description:         "Whether network throttling is enabled for vtree migration.",
                MarkdownDescription: "Whether network throttling is enabled for vtree migration.",
                Computed:            true,
        },
        "vtree_migration_network_throttling_in_kbps": schema.Int64Attribute{
                Description:         "Maximum allowed io for vtree migration in KBps.",
                MarkdownDescription: "Maximum allowed io for vtree migration in KBps.",
                Computed:            true,
        },
        "overall_io_network_throttling_enabled": schema.BoolAttribute{
                Description:         "Whether network throttling is enabled for overall io.",
                MarkdownDescription: "Whether network throttling is enabled for overall io.",
                Computed:            true,
        },
        "overall_io_network_throttling_in_kbps": schema.Int64Attribute{
                Description:         "Maximum allowed io for protected maintenance mode in KBps. Must be greater than any other network throttling parameter.",
                MarkdownDescription: "Maximum allowed io for protected maintenance mode in KBps. Must be greater than any other network throttling parameter.",
                Computed:            true,
        },
        "sdr_sds_connectivity": schema.SingleNestedAttribute{
                Description:         "SDR-SDS Connectivity information.",
                MarkdownDescription: "SDR-SDS Connectivity information.",
                Computed:            true,
                Attributes: map[string]schema.Attribute{
                        "client_server_conn_status": schema.StringAttribute{
                                Description:         "Connectivity Status.",
                                MarkdownDescription: "Connectivity Status.",
                                Computed:            true,
                        },
                        "disconnected_client_id": schema.StringAttribute{
                                Description:         "ID of the disconnected client.",
                                MarkdownDescription: "ID of the disconnected client.",
                                Computed:            true,
                        },
                        "disconnected_client_name": schema.StringAttribute{
                                Description:         "Name of the disconnected client.",
                                MarkdownDescription: "Name of the disconnected client.",
                                Computed:            true,
                        },
                        "disconnected_server_id": schema.StringAttribute{
                                Description:         "ID of the disconnected server.",
                                MarkdownDescription: "ID of the disconnected server.",
                                Computed:            true,
                        },
                        "disconnected_server_name": schema.StringAttribute{
                                Description:         "Name of the disconnected server.",
                                MarkdownDescription: "Name of the disconnected server.",
                                Computed:            true,
                        },
                        "disconnected_server_ip": schema.StringAttribute{
                                Description:         "IP address of the disconnected server.",
                                MarkdownDescription: "IP address of the disconnected server.",
                                Computed:            true,
                        },
                },
        },
        "sds_decoupled_counter": schema.SingleNestedAttribute{
                Description:         "SDS Decoupled Counter windows.",
                MarkdownDescription: "SDS Decoupled Counter windows.",
                Computed:            true,
                Attributes:          getAllWindowParamsSchema(),
        },
        "sds_configuration_failure_counter": schema.SingleNestedAttribute{
                Description:         "SDS Configuration Failure Counter windows.",
                MarkdownDescription: "SDS Configuration Failure Counter windows.",
                Computed:            true,
                Attributes:          getAllWindowParamsSchema(),
        },
        "mdm_sds_network_disconnections_counter": schema.SingleNestedAttribute{
                Description:         "MDM-SDS Network Disconnection Counter windows.",
                MarkdownDescription: "MDM-SDS Network Disconnection Counter windows.",
                Computed:            true,
                Attributes:          getAllWindowParamsSchema(),
        },
        "sds_sds_network_disconnections_counter": schema.SingleNestedAttribute{
                Description:         "SDS-SDS Network Disconnection Counter windows.",
                MarkdownDescription: "SDS-SDS Network Disconnection Counter windows.",
                Computed:            true,
                Attributes:          getAllWindowParamsSchema(),
        },
        "sds_receive_buffer_allocation_failures_counter": schema.SingleNestedAttribute{
                Description:         "SDS receive Buffer Allocation Failure Counter windows.",
                MarkdownDescription: "SDS receive Buffer Allocation Failure Counter windows.",
                Computed:            true,
                Attributes:          getAllWindowParamsSchema(),
        },
        "replication_capacity_max_ratio": schema.Int64Attribute{
                Description:         "Maximum Replication Capacity Ratio.",
                MarkdownDescription: "Maximum Replication Capacity Ratio.",
                Computed:            true,
        },
        "links": schema.ListNestedAttribute{
                Description:         "Underlying REST API links.",
                MarkdownDescription: "Underlying REST API links.",
                Computed:            true,
                NestedObject: schema.NestedAttributeObject{
                        Attributes: map[string]schema.Attribute{
                                "rel": schema.StringAttribute{
                                        Description:         "Specifies the relationship with the Protection Domain.",
                                        MarkdownDescription: "Specifies the relationship with the Protection Domain.",
                                        Computed:            true,
                                },
                                "href": schema.StringAttribute{
                                        Description:         "Specifies the exact path to fetch the details.",
                                        MarkdownDescription: "Specifies the exact path to fetch the details.",
                                        Computed:            true,
                                },
                        },
                },
        },
}

func getAllWindowParamsSchema() map[string]schema.Attribute <span class="cov8" title="1">{
        return map[string]schema.Attribute{
                "short_window": schema.SingleNestedAttribute{
                        Description:         "Short Window Parameters.",
                        MarkdownDescription: "Short Window Parameters.",
                        Computed:            true,
                        Attributes:          getWindowParamsSchema(),
                },
                "medium_window": schema.SingleNestedAttribute{
                        Description:         "Medium Window Parameters.",
                        MarkdownDescription: "Medium Window Parameters.",
                        Computed:            true,
                        Attributes:          getWindowParamsSchema(),
                },
                "long_window": schema.SingleNestedAttribute{
                        Description:         "Long Window Parameters.",
                        MarkdownDescription: "Long Window Parameters.",
                        Computed:            true,
                        Attributes:          getWindowParamsSchema(),
                },
        }
}</span>

func getWindowParamsSchema() map[string]schema.Attribute <span class="cov8" title="1">{
        return map[string]schema.Attribute{
                "threshold": schema.Int64Attribute{
                        Description:         "Threshold.",
                        MarkdownDescription: "Threshold.",
                        Computed:            true,
                },
                "window_size_in_sec": schema.Int64Attribute{
                        Description:         "Window Size in seconds.",
                        MarkdownDescription: "Window Size in seconds.",
                        Computed:            true,
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package powerflex

import (
        "context"
        "os"

        "github.com/dell/goscaleio"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/provider"
        "github.com/hashicorp/terraform-plugin-framework/provider/schema"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
        _ provider.Provider = &amp;powerflexProvider{}
)

// New - returns new provider struct definition.
func New() provider.Provider <span class="cov8" title="1">{
        return &amp;powerflexProvider{}
}</span>

type powerflexProvider struct{}

// powerflexProviderModel - provider input struct.
type powerflexProviderModel struct {
        EndPoint types.String `tfsdk:"endpoint"`
        Username types.String `tfsdk:"username"`
        Password types.String `tfsdk:"password"`
        Insecure types.Bool   `tfsdk:"insecure"`
}

// Metadata - provider metadata AKA name.
func (p *powerflexProvider) Metadata(_ context.Context, _ provider.MetadataRequest, resp *provider.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = "powerflex"
}</span>

// GetSchema - provider schema.
func (p *powerflexProvider) Schema(_ context.Context, _ provider.SchemaRequest, resp *provider.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = schema.Schema{
                Description: "",
                Attributes: map[string]schema.Attribute{
                        "endpoint": schema.StringAttribute{
                                Description:         "the endpoint to which it needs to be connected.",
                                MarkdownDescription: "the endpoint to which it needs to be connected.",
                                Required:            true,
                        },
                        "username": schema.StringAttribute{
                                Description:         "The username required for authentication.",
                                MarkdownDescription: "The username required for authentication.",
                                Required:            true,
                        },
                        "password": schema.StringAttribute{
                                Description:         "The password required for the authentication.",
                                MarkdownDescription: "The password required for the authentication.",
                                Required:            true,
                                Sensitive:           true,
                        },
                        "insecure": schema.BoolAttribute{
                                Description:         "Specifies if the user wants to do SSL verification.",
                                MarkdownDescription: "Specifies if the user wants to do SSL verification.",
                                Optional:            true,
                        },
                },
        }
}</span>

// Configure - provider pre-initiate calle function.
func (p *powerflexProvider) Configure(ctx context.Context, req provider.ConfigureRequest, resp *provider.ConfigureResponse) <span class="cov8" title="1">{
        tflog.Info(ctx, "Configuring powerflex client")

        var config powerflexProviderModel
        diags := req.Config.Get(ctx, &amp;config)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if config.EndPoint.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("endpoint"),
                        "Unknown powerflex API EndPoint",
                        "The provider cannot create the powerflex API client as there is an unknown configuration value for the powerflex API endpoint. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the POWERFLEX_ENDPOINT environment variable.",
                )
        }</span>

        <span class="cov8" title="1">if config.Username.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("username"),
                        "Unknown powerflex API Username",
                        "The provider cannot create the powerflex API client as there is an unknown configuration value for the powerflex API username. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the POWERFLEX_USERNAME environment variable.",
                )
        }</span>

        <span class="cov8" title="1">if config.Password.IsUnknown() </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("password"),
                        "Unknown powerflex API Password",
                        "The provider cannot create the powerflex API client as there is an unknown configuration value for the powerflex API password. "+
                                "Either target apply the source of the value first, set the value statically in the configuration, or use the POWERFLEX_PASSWORD environment variable.",
                )
        }</span>

        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">endpoint := os.Getenv("POWERFLEX_ENDPOINT")
        username := os.Getenv("POWERFLEX_USERNAME")
        password := os.Getenv("POWERFLEX_PASSWORD")
        insecure := os.Getenv("POWERFLEX_INSECURE") == "true"

        if !config.EndPoint.IsNull() </span><span class="cov8" title="1">{
                endpoint = config.EndPoint.ValueString()
        }</span>

        <span class="cov8" title="1">if !config.Username.IsNull() </span><span class="cov8" title="1">{
                username = config.Username.ValueString()
        }</span>

        <span class="cov8" title="1">if !config.Password.IsNull() </span><span class="cov8" title="1">{
                password = config.Password.ValueString()
        }</span>
        <span class="cov8" title="1">if !config.Insecure.IsNull() </span><span class="cov0" title="0">{
                insecure = config.Insecure.ValueBool()
        }</span>

        <span class="cov8" title="1">if endpoint == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("endpoint"),
                        "Missing powerflex API Endpoint",
                        "The provider cannot create the powerflex API client as there is a missing or empty value for the powerflex API endpoint. "+
                                "Set the endpoint value in the configuration or use the POWERFLEX_ENDPOINT environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov8" title="1">if username == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("username"),
                        "Missing powerflex API Username",
                        "The provider cannot create the powerflex API client as there is a missing or empty value for the powerflex API username. "+
                                "Set the username value in the configuration or use the POWERFLEX_USERNAME environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov8" title="1">if password == "" </span><span class="cov0" title="0">{
                resp.Diagnostics.AddAttributeError(
                        path.Root("password"),
                        "Missing powerflex API Password",
                        "The provider cannot create the powerflex API client as there is a missing or empty value for the powerflex API password. "+
                                "Set the password value in the configuration or use the POWERFLEX_PASSWORD environment variable. "+
                                "If either is already set, ensure the value is not empty.",
                )
        }</span>

        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">ctx = tflog.SetField(ctx, "powerflex_endpoint", endpoint)
        ctx = tflog.SetField(ctx, "powerflex_username", username)
        ctx = tflog.SetField(ctx, "powerflex_password", password)
        ctx = tflog.MaskFieldValuesWithFieldKeys(ctx, "powerflex_password")
        ctx = tflog.SetField(ctx, "insecure", insecure)
        tflog.Debug(ctx, "Creating powerflex client")

        // Create a new powerflex client using the configuration values
        Client, err := goscaleio.NewClientWithArgs(endpoint, "", true, true)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Create powerflex API Client",
                        "An unexpected error occurred when creating the powerflex API client. "+
                                "If the error is not clear, please contact the provider developers.\n\n"+
                                "powerflex Client Error: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">var goscaleioConf goscaleio.ConfigConnect = goscaleio.ConfigConnect{}
        goscaleioConf.Endpoint = endpoint
        goscaleioConf.Username = username
        goscaleioConf.Version = ""
        goscaleioConf.Password = password

        _, err = Client.Authenticate(&amp;goscaleioConf)

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Authenticate Goscaleio API Client",
                        "An unexpected error occurred when authenticating the Goscaleio API Client. "+
                                "Unable to Authenticate Goscaleio API Client.\n\n"+
                                "powerflex Client Error: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">resp.DataSourceData = Client
        resp.ResourceData = Client

        tflog.Info(ctx, "Configured powerflex client", map[string]any{"success": true})</span>
}

// DataSources - returns array of all datasources.
func (p *powerflexProvider) DataSources(_ context.Context) []func() datasource.DataSource <span class="cov8" title="1">{
        return []func() datasource.DataSource{
                VolumeDataSource,
                SDCDataSource,
                ProtectionDomainDataSource,
                StoragePoolDataSource,
                SnapshotPolicyDataSource,
        }
}</span>

// Resources defines the resources implemented in the provider.
func (p *powerflexProvider) Resources(_ context.Context) []func() resource.Resource <span class="cov8" title="1">{
        return []func() resource.Resource{
                NewSDSResource,
                NewVolumeResource,
                SDCResource,
                StoragepoolResource,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package powerflex

import (
        "context"

        "terraform-provider-powerflex/helper"

        "github.com/dell/goscaleio"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
        _ datasource.DataSource              = &amp;sdcDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;sdcDataSource{}
)

// SDCDataSource - function used to return SDC DataSource provider with singleton values.
func SDCDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;sdcDataSource{}
}</span>

// Metadata - function used to define datasource metadata[referance in tf file].
func (d *sdcDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_sdc"
}</span>

// GetSchema - function used to return SDC datasource schema.
func (d *sdcDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = SDCDataSourceScheme
}</span>

// Configure - function to call initial configurations before resource execution.
func (d *sdcDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">d.client = req.ProviderData.(*goscaleio.Client)</span>
}

// Read - function to read sdc values from goscaleio.
func (d *sdcDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var state sdcDataSourceModel
        diags := req.Config.Get(ctx, &amp;state)
        tflog.Info(ctx, "[POWERFLEX] sdcDataSourceModel"+helper.PrettyJSON((state)))

        system, err := getFirstSystem(d.client)

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex specific system",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">sdcs, err := system.GetSdc()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex sdcs",
                        err.Error(),
                )
                return
        }</span>
        // Set state
        <span class="cov8" title="1">searchFilter := sdcFilterType.All
        if state.Name.ValueString() != "" </span><span class="cov8" title="1">{
                searchFilter = sdcFilterType.ByName
        }</span>
        <span class="cov8" title="1">if state.ID.ValueString() != "" </span><span class="cov8" title="1">{
                searchFilter = sdcFilterType.ByID
        }</span>

        <span class="cov8" title="1">allSdcWithStats, _ := getAllSdcState(ctx, *d.client, sdcs)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Statics for sdc id = "+state.ID.ValueString()+", name = "+state.Name.ValueString(),
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">if searchFilter == sdcFilterType.All </span><span class="cov0" title="0">{
                state.Sdcs = *allSdcWithStats
        }</span> else<span class="cov8" title="1"> {
                filterResult := getFilteredSdcState(allSdcWithStats, searchFilter, state.Name.ValueString(), state.ID.ValueString())
                state.Sdcs = *filterResult
        }</span>

        <span class="cov8" title="1">state.Name = types.StringValue(state.Name.ValueString())
        state.ID = types.StringValue(state.ID.ValueString())

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package powerflex

import (
        "context"

        "github.com/dell/goscaleio"
        scaleiotypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// sdcFilterType - Enum structure for filter types.
var sdcFilterType = struct {
        All    string
        ByName string
        ByID   string
}{
        All:    "All",
        ByName: "ByName",
        ByID:   "ByID",
}

// sdcDataSource - for returning singleton holder with goscaleio client.
type sdcDataSource struct {
        client *goscaleio.Client
}

// sdcDataSourceModel - for returning result to terraform.
type sdcDataSourceModel struct {
        ID   types.String `tfsdk:"id"`
        Sdcs []sdcModel   `tfsdk:"sdcs"`
        Name types.String `tfsdk:"name"`
}

// sdcModel - MODEL for SDC data returned by goscaleio.
type sdcModel struct {
        ID                 types.String   `tfsdk:"id"`
        SystemID           types.String   `tfsdk:"system_id"`
        SdcIP              types.String   `tfsdk:"sdc_ip"`
        SdcApproved        types.Bool     `tfsdk:"sdc_approved"`
        OnVMWare           types.Bool     `tfsdk:"on_vmware"`
        SdcGUID            types.String   `tfsdk:"sdc_guid"`
        MdmConnectionState types.String   `tfsdk:"mdm_connection_state"`
        Name               types.String   `tfsdk:"name"`
        Links              []sdcLinkModel `tfsdk:"links"`
}

// sdcLinkModel - MODEL for SDC Links data returned by goscaleio.
type sdcLinkModel struct {
        Rel  types.String `tfsdk:"rel"`
        HREF types.String `tfsdk:"href"`
}

// getFilteredSdcState - function to filter sdc result from goscaleio.
func getFilteredSdcState(sdcs *[]sdcModel, method string, name string, id string) *[]sdcModel <span class="cov8" title="1">{
        response := []sdcModel{}
        for _, sdcValue := range *sdcs </span><span class="cov8" title="1">{
                if method == sdcFilterType.ByName &amp;&amp; name == sdcValue.Name.ValueString() </span><span class="cov8" title="1">{
                        response = append(response, sdcValue)
                }</span>
                <span class="cov8" title="1">if method == sdcFilterType.ByID &amp;&amp; id == sdcValue.ID.ValueString() </span><span class="cov8" title="1">{
                        response = append(response, sdcValue)
                }</span>
        }
        <span class="cov8" title="1">return &amp;response</span>
}

// getAllSdcState - function to return all sdc result from goscaleio.
func getAllSdcState(ctx context.Context, client goscaleio.Client, sdcs []scaleiotypes.Sdc) (*[]sdcModel, error) <span class="cov8" title="1">{
        response := []sdcModel{}
        for _, sdcValue := range sdcs </span><span class="cov8" title="1">{
                sdcState := sdcModel{
                        ID:                 types.StringValue(sdcValue.ID),
                        Name:               types.StringValue(sdcValue.Name),
                        SdcGUID:            types.StringValue(sdcValue.SdcGUID),
                        SdcApproved:        types.BoolValue(sdcValue.SdcApproved),
                        OnVMWare:           types.BoolValue(sdcValue.OnVMWare),
                        SystemID:           types.StringValue(sdcValue.SystemID),
                        SdcIP:              types.StringValue(sdcValue.SdcIP),
                        MdmConnectionState: types.StringValue(sdcValue.MdmConnectionState),
                }

                for _, link := range sdcValue.Links </span><span class="cov8" title="1">{
                        sdcState.Links = append(sdcState.Links, sdcLinkModel{
                                Rel:  types.StringValue(link.Rel),
                                HREF: types.StringValue(link.HREF),
                        })
                }</span>

                <span class="cov8" title="1">response = append(response, sdcState)</span>
        }

        <span class="cov8" title="1">return &amp;response, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package powerflex

import (
        "context"
        "fmt"
        "terraform-provider-powerflex/helper"
        "time"

        "github.com/dell/goscaleio"
        scaleiotypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
        _ resource.Resource                = &amp;sdcResource{}
        _ resource.ResourceWithConfigure   = &amp;sdcResource{}
        _ resource.ResourceWithImportState = &amp;sdcResource{}
)

// SDCResource - function to return resource interface
func SDCResource() resource.Resource <span class="cov8" title="1">{
        return &amp;sdcResource{}
}</span>

// sdcResource - struct to define sdc resource
type sdcResource struct {
        client *goscaleio.Client
}

// sdcResourceModel - struct to define sdc resource structure.
type sdcResourceModel struct {
        ID                 types.String `tfsdk:"id"`
        LastUpdated        types.String `tfsdk:"last_updated"`
        SystemID           types.String `tfsdk:"system_id"`
        Name               types.String `tfsdk:"name"`
        SdcIP              types.String `tfsdk:"sdc_ip"`
        SdcApproved        types.Bool   `tfsdk:"sdc_approved"`
        OnVMWare           types.Bool   `tfsdk:"on_vmware"`
        SdcGUID            types.String `tfsdk:"sdc_guid"`
        MdmConnectionState types.String `tfsdk:"mdm_connection_state"`
        Links              types.List   `tfsdk:"links"`
}

// Metadata - function to return metadata for SDC resource.
func (r *sdcResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_sdc"
}</span>

// Schema - function to return Schema for SDC resource.
func (r *sdcResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = SDCReourceSchema
}</span>

// Configure - function to return Configuration for SDC resource.
func (r *sdcResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.client = req.ProviderData.(*goscaleio.Client)</span>
}

// Create - function to Create for SDC resource.
func (r *sdcResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "[POWERFLEX] Create")

        var plan sdcResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">system, err := getFirstSystem(r.client)

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex systems sdcs Create",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">nameChng, err := system.ChangeSdcName(plan.ID.ValueString(), plan.Name.ValueString())

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "[Create] Unable to Change name Powerflex sdc",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">sdcs, err := system.GetSdc()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex sdcs",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">finalSDC, err := findChangedSdc(sdcs, plan.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Changed SDC",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">plan = getSdcState(*finalSDC)

        tflog.Debug(ctx, "[POWERFLEX] nameChng Result :-- "+helper.PrettyJSON(nameChng))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">plan.LastUpdated = types.StringValue(time.Now().Format(time.RFC850))

        // Set state to fully populated data
        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">plan.LastUpdated = types.StringValue(time.Now().Format(time.RFC850))

        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Read - function to Read for SDC resource.
func (r *sdcResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "[POWERFLEX] Read")
        // Get current state
        var state sdcResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">system, err := getFirstSystem(r.client)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex systems Read",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">singleSdc, err := system.FindSdc("ID", state.ID.ValueString())

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex systems-sdcs Read",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">state = getSdcState(*singleSdc.Sdc)

        // tflog.Debug(ctx, "[POWERFLEX] state return"+helper.PrettyJSON(state))
        // Set refreshed state
        diags = resp.State.Set(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Update - function to Update for SDC resource.
func (r *sdcResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "[POWERFLEX] Update")
        // Retrieve values from plan
        var plan sdcResourceModel
        var state sdcResourceModel
        req.State.Get(ctx, &amp;state)
        diags := req.Plan.Get(ctx, &amp;plan)

        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">system, err := getFirstSystem(r.client)

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex systems sdcs Create",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">if state.Name.ValueString() == plan.Name.ValueString() </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "[Create] Same name alredy exists.",
                                err.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov8" title="1">nameChng, err := system.ChangeSdcName(plan.ID.ValueString(), plan.Name.ValueString())

        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "[Create] Unable to Change name Powerflex sdc",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">sdcs, err := system.GetSdc()
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex sdcs",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">finalSDC, err := findChangedSdc(sdcs, plan.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Changed SDC",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">plan = getSdcState(*finalSDC)

        tflog.Debug(ctx, "[POWERFLEX] nameChng Result :-- "+helper.PrettyJSON(nameChng))

        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">plan.LastUpdated = types.StringValue(time.Now().Format(time.RFC850))

        // Set state to fully populated data
        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">plan.LastUpdated = types.StringValue(time.Now().Format(time.RFC850))

        // Set state to fully populated data
        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Delete - function to Delete for SDC resource.
func (r *sdcResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "[POWERFLEX] Delete")
        // Retrieve values from state
        var state sdcResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

}

// ImportState - function to ImportState for SDC resource.
func (r *sdcResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "[POWERFLEX] ImportState :-- "+helper.PrettyJSON(req))
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

// getSdcState - function to return all sdc result from goscaleio.
func getSdcState(sdc scaleiotypes.Sdc) (response sdcResourceModel) <span class="cov8" title="1">{
        // var basenameOpts []sdcModel = []sdcModel{}
        pln := sdcResourceModel{
                ID:                 types.StringValue(sdc.ID),
                Name:               types.StringValue(sdc.Name),
                SdcGUID:            types.StringValue(sdc.SdcGUID),
                SdcApproved:        types.BoolValue(sdc.SdcApproved),
                OnVMWare:           types.BoolValue(sdc.OnVMWare),
                SystemID:           types.StringValue(sdc.SystemID),
                SdcIP:              types.StringValue(sdc.SdcIP),
                MdmConnectionState: types.StringValue(sdc.MdmConnectionState),
        }
        pln.ID = types.StringValue(sdc.ID)
        sourceKeywordAttrTypes := map[string]attr.Type{
                "rel":  types.StringType,
                "href": types.StringType,
        }
        elemType := types.ObjectType{AttrTypes: sourceKeywordAttrTypes}
        objLinksList := []attr.Value{}

        for _, link := range sdc.Links </span><span class="cov8" title="1">{
                obj := map[string]attr.Value{
                        "rel":  types.StringValue(link.Rel),
                        "href": types.StringValue(link.HREF),
                }
                objVal, _ := types.ObjectValue(sourceKeywordAttrTypes, obj)
                objLinksList = append(objLinksList, objVal)
        }</span>

        <span class="cov8" title="1">listVal, _ := types.ListValue(elemType, objLinksList)

        pln.Links = listVal
        return pln</span>
}

// findChangedSdc - find sdc which is changed on behalf of id.
func findChangedSdc(sdcs []scaleiotypes.Sdc, id string) (*scaleiotypes.Sdc, error) <span class="cov8" title="1">{
        var sdcReturnValue scaleiotypes.Sdc
        var found bool
        for _, sdcValue := range sdcs </span><span class="cov8" title="1">{

                if id == sdcValue.ID </span><span class="cov8" title="1">{
                        found = true
                        sdcReturnValue = sdcValue
                }</span>

        }

        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                return &amp;sdcReturnValue, nil
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("SDC Not Found")</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package powerflex

import (
        "context"
        "fmt"
        "time"

        scaleiotypes "github.com/dell/goscaleio/types/v1"

        "github.com/dell/goscaleio"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/diag"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// SDSResourceModel maps the resource schema data.
type sdsResourceModel struct {
        ID                           types.String `tfsdk:"id"`
        Name                         types.String `tfsdk:"name"`
        ProtectionDomainID           types.String `tfsdk:"protection_domain_id"`
        ProtectionDomainName         types.String `tfsdk:"protection_domain_name"`
        IPList                       types.Set    `tfsdk:"ip_list"`
        Port                         types.Int64  `tfsdk:"port"`
        SdsState                     types.String `tfsdk:"sds_state"`
        MembershipState              types.String `tfsdk:"membership_state"`
        MdmConnectionState           types.String `tfsdk:"mdm_connection_state"`
        DrlMode                      types.String `tfsdk:"drl_mode"`
        RmcacheEnabled               types.Bool   `tfsdk:"rmcache_enabled"`
        RmcacheSizeInMB              types.Int64  `tfsdk:"rmcache_size_in_mb"`
        RfcacheEnabled               types.Bool   `tfsdk:"rfcache_enabled"`
        RmcacheFrozen                types.Bool   `tfsdk:"rmcache_frozen"`
        IsOnVMware                   types.Bool   `tfsdk:"is_on_vmware"`
        FaultSetID                   types.String `tfsdk:"fault_set_id"`
        NumOfIoBuffers               types.Int64  `tfsdk:"num_of_io_buffers"`
        RmcacheMemoryAllocationState types.String `tfsdk:"rmcache_memory_allocation_state"`
        PerformanceProfile           types.String `tfsdk:"performance_profile"`
}

// SDS IP object
type sdsIPModel struct {
        IP   types.String `tfsdk:"ip"`
        Role types.String `tfsdk:"role"`
}

var (
        _ resource.Resource                = &amp;sdsResource{}
        _ resource.ResourceWithConfigure   = &amp;sdsResource{}
        _ resource.ResourceWithImportState = &amp;sdsResource{}
)

// NewSDSResource is a helper function to simplify the provider implementation.
func NewSDSResource() resource.Resource <span class="cov8" title="1">{
        return &amp;sdsResource{}
}</span>

// sdsResource is the resource implementation.
type sdsResource struct {
        client *goscaleio.Client
}

func (r *sdsResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_sds"
}</span>

func (r *sdsResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = SDSResourceSchema
}</span>

func (r *sdsResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.client = req.ProviderData.(*goscaleio.Client)</span>
}

// Conversion of list of IPs from tf model to go type
func (sds *sdsResourceModel) getIPList(ctx context.Context) []*scaleiotypes.SdsIP <span class="cov8" title="1">{
        iplist := []*scaleiotypes.SdsIP{}
        var ipModellist []sdsIPModel
        sds.IPList.ElementsAs(ctx, &amp;ipModellist, false)
        for _, v := range ipModellist </span><span class="cov8" title="1">{
                sdsIP := scaleiotypes.SdsIP{
                        IP:   v.IP.ValueString(),
                        Role: v.Role.ValueString(),
                }
                iplist = append(iplist, &amp;sdsIP)
        }</span>
        <span class="cov8" title="1">return iplist</span>
}

// Gte difference between sets of IP in state and plan
func sdsIPListDiff(ctx context.Context, plan, state *sdsResourceModel) (toAdd, toRmv, changed, common []*scaleiotypes.SdsIP) <span class="cov8" title="1">{
        plist, slist := plan.getIPList(ctx), state.getIPList(ctx)
        type ipObj struct {
                pip *scaleiotypes.SdsIP
                sip *scaleiotypes.SdsIP
        }
        vmap := make(map[string]*ipObj)
        for _, pip := range plist </span><span class="cov8" title="1">{
                vmap[pip.IP] = &amp;ipObj{pip, nil}
        }</span>
        <span class="cov8" title="1">for _, sip := range slist </span><span class="cov8" title="1">{
                if mip, ok := vmap[sip.IP]; ok </span><span class="cov8" title="1">{
                        mip.sip = sip
                }</span> else<span class="cov8" title="1"> {
                        vmap[sip.IP] = &amp;ipObj{nil, sip}
                }</span>
        }
        <span class="cov8" title="1">toAdd, toRmv, common, changed = make([]*scaleiotypes.SdsIP, 0), make([]*scaleiotypes.SdsIP, 0),
                make([]*scaleiotypes.SdsIP, 0), make([]*scaleiotypes.SdsIP, 0)
        for _, mip := range vmap </span><span class="cov8" title="1">{
                if mip.sip != nil </span><span class="cov8" title="1">{
                        if mip.pip != nil </span><span class="cov8" title="1">{
                                if mip.pip.Role == mip.sip.Role </span><span class="cov8" title="1">{
                                        common = append(common, mip.pip)
                                }</span> else<span class="cov8" title="1"> {
                                        changed = append(changed, mip.pip)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                toRmv = append(toRmv, mip.sip)
                                // toAdd = append(toAdd, mip.pip)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // toRmv = append(toRmv, mip.pip)
                        toAdd = append(toAdd, mip.pip)
                }</span>
        }
        <span class="cov8" title="1">return toAdd, toRmv, changed, common</span>
}

// Create creates the resource and sets the initial Terraform state.
func (r *sdsResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        // Retrieve values from plan
        var plan sdsResourceModel

        diags := req.Plan.Get(ctx, &amp;plan)

        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pdm, err := getNewProtectionDomainEx(r.client, plan.ProtectionDomainID.ValueString(), plan.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">sdsName := plan.Name.ValueString()
        iplist := plan.getIPList(ctx)

        params := scaleiotypes.Sds{
                Name:   sdsName,
                IPList: iplist,
        }
        if !plan.RmcacheEnabled.IsNull() </span><span class="cov8" title="1">{
                params.RmcacheEnabled = plan.RmcacheEnabled.ValueBool()
        }</span>
        <span class="cov8" title="1">if !plan.RmcacheSizeInMB.IsNull() </span><span class="cov8" title="1">{
                params.RmcacheSizeInKb = int(plan.RmcacheSizeInMB.ValueInt64()) * 1024
        }</span>
        <span class="cov8" title="1">if !plan.DrlMode.IsNull() </span><span class="cov8" title="1">{
                params.DrlMode = plan.DrlMode.ValueString()
        }</span>
        <span class="cov8" title="1">if !plan.Port.IsNull() </span><span class="cov8" title="1">{
                params.Port = int(plan.Port.ValueInt64())
        }</span>
        <span class="cov8" title="1">sdsID, err2 := pdm.CreateSdsWithParams(&amp;params)
        if err2 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        fmt.Sprintf("Could not create SDS with name %s and IP list %v", sdsName, iplist),
                        err2.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">if !plan.RfcacheEnabled.IsUnknown() </span><span class="cov8" title="1">{
                time.Sleep(1 * time.Second)
                rfCacheEnabled := plan.RfcacheEnabled.ValueBool()
                err := pdm.SetSdsRfCache(sdsID, rfCacheEnabled)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not set SDS Rf Cache settings to %t", rfCacheEnabled),
                                err.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">if !plan.PerformanceProfile.IsUnknown() </span><span class="cov8" title="1">{
                perfprof := plan.PerformanceProfile.ValueString()
                err := pdm.SetSdsPerformanceProfile(sdsID, perfprof)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not set SDS Performance Profile settings to %s", perfprof),
                                err.Error(),
                        )
                        return
                }</span>
        }

        // Get created SDS
        <span class="cov8" title="1">rsp, err3 := pdm.FindSds("ID", sdsID)
        if err3 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting SDS after creation",
                        err3.Error(),
                )
                return
        }</span>

        // Set refreshed state
        <span class="cov8" title="1">state, dgs := updateSdsState(rsp, plan)
        resp.Diagnostics.Append(dgs...)

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)</span>
}

// Read refreshes the Terraform state with the latest data.
func (r *sdsResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        // Retrieve values from state
        var state sdsResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pdm, err := getNewProtectionDomainEx(r.client, state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        err.Error(),
                )
                return
        }</span>

        // Get SDS
        <span class="cov8" title="1">var rsp *scaleiotypes.Sds
        if rsp, err = pdm.FindSds("ID", state.ID.ValueString()); err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Could not get SDS",
                        err.Error(),
                )
                return
        }</span>

        // Set refreshed state
        <span class="cov8" title="1">state, dgs := updateSdsState(rsp, state)
        resp.Diagnostics.Append(dgs...)

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Update updates the resource and sets the updated Terraform state on success.
func (r *sdsResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        // Retrieve values from plan
        var plan sdsResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Retrieve values from state
        <span class="cov8" title="1">var state sdsResourceModel
        diags = req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pdm, err := getNewProtectionDomainEx(r.client, state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        err.Error(),
                )
                return
        }</span>

        // Check if there difference between plan and state
        <span class="cov8" title="1">if plan.Name.ValueString() != state.Name.ValueString() </span><span class="cov8" title="1">{
                err := pdm.SetSdsName(state.ID.ValueString(), plan.Name.ValueString())
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Could not rename SDS",
                                err.Error(),
                        )

                        return
                }</span>
        }

        // Check if there are updates in ip lists
        <span class="cov8" title="1">toAdd, toRmv, changed, _ := sdsIPListDiff(ctx, &amp;plan, &amp;state)
        for _, ip := range toAdd </span><span class="cov8" title="1">{
                err := pdm.AddSdSIP(state.ID.ValueString(), ip.IP, ip.Role)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Error adding IP %s to SDS with role %s", ip.IP, ip.Role),
                                err.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, ip := range changed </span><span class="cov8" title="1">{
                err := pdm.SetSDSIPRole(state.ID.ValueString(), ip.IP, ip.Role)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Error updating IP %s role to %s in SDS", ip.IP, ip.Role),
                                err.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, ip := range toRmv </span><span class="cov8" title="1">{
                err := pdm.RemoveSDSIP(state.ID.ValueString(), ip.IP)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Error removing IP %s with role %s from SDS", ip.IP, ip.Role),
                                err.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // check if there is change in sds port
        <span class="cov8" title="1">if !plan.Port.IsUnknown() &amp;&amp; !state.Port.Equal(plan.Port) </span><span class="cov0" title="0">{
                port := plan.Port.ValueInt64()
                err := pdm.SetSdsPort(state.ID.ValueString(), int(port))
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not change SDS port to %d", port),
                                err.Error(),
                        )

                        return
                }</span>
        }

        // check if there is change in sds drl mode
        <span class="cov8" title="1">if !plan.DrlMode.IsUnknown() &amp;&amp; !state.DrlMode.Equal(plan.DrlMode) </span><span class="cov8" title="1">{
                drlMode := plan.DrlMode.ValueString()
                err := pdm.SetSdsDrlMode(state.ID.ValueString(), drlMode)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not change SDS DRL Mode to %s", drlMode),
                                err.Error(),
                        )
                        return
                }</span>
        }

        // check if there is change in sds rmcache
        <span class="cov8" title="1">if !plan.RmcacheEnabled.IsUnknown() &amp;&amp; !state.RmcacheEnabled.Equal(plan.RmcacheEnabled) </span><span class="cov8" title="1">{
                rmCacheEnabled := plan.RmcacheEnabled.ValueBool()
                err := pdm.SetSdsRmCache(state.ID.ValueString(), rmCacheEnabled)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not change SDS Read Ram Cache settings to %t", rmCacheEnabled),
                                err.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov8" title="1">if !plan.RmcacheSizeInMB.IsUnknown() &amp;&amp; !state.RmcacheSizeInMB.Equal(plan.RmcacheSizeInMB) </span><span class="cov8" title="1">{
                rmCacheSize := plan.RmcacheSizeInMB.ValueInt64()
                err := pdm.SetSdsRmCacheSize(state.ID.ValueString(), int(rmCacheSize))
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not change SDS Read Ram Cache size to %d", rmCacheSize),
                                err.Error(),
                        )
                        return
                }</span>
        }

        // check if there is change in sds rfcache
        <span class="cov8" title="1">if !plan.RfcacheEnabled.IsUnknown() &amp;&amp; !state.RfcacheEnabled.Equal(plan.RfcacheEnabled) </span><span class="cov8" title="1">{
                rfCacheEnabled := plan.RfcacheEnabled.ValueBool()
                err := pdm.SetSdsRfCache(state.ID.ValueString(), rfCacheEnabled)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not change SDS Rf Cache settings to %t", rfCacheEnabled),
                                err.Error(),
                        )
                        return
                }</span>
        }

        // Check if performance profile has been changed
        <span class="cov8" title="1">if !plan.PerformanceProfile.IsUnknown() &amp;&amp; !state.PerformanceProfile.Equal(plan.PerformanceProfile) </span><span class="cov8" title="1">{
                perfprof := plan.PerformanceProfile.ValueString()
                err := pdm.SetSdsPerformanceProfile(state.ID.ValueString(), perfprof)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                fmt.Sprintf("Could not set SDS Performance Profile settings to %s", perfprof),
                                err.Error(),
                        )
                        return
                }</span>
        }

        // Find updated SDS
        <span class="cov8" title="1">rsp, err := pdm.FindSds("ID", state.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting SDS after updation",
                        err.Error(),
                )
                return
        }</span>

        // Set refreshed state
        <span class="cov8" title="1">state, dgs := updateSdsState(rsp, plan)
        resp.Diagnostics.Append(dgs...)

        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Delete deletes the resource and removes the Terraform state on success.
func (r *sdsResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        // Retrieve values from state
        var state sdsResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pdm, err := getNewProtectionDomainEx(r.client, state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        err.Error(),
                )
                return
        }</span>

        // Delete SDS
        <span class="cov8" title="1">err = pdm.DeleteSds(state.ID.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to delete Powerflex SDS",
                        err.Error(),
                )

                return
        }</span>

        <span class="cov8" title="1">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">resp.State.RemoveResource(ctx)</span>

}

func (r *sdsResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        // Retrieve import ID and save to id attribute
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

func updateSdsState(sds *scaleiotypes.Sds, plan sdsResourceModel) (sdsResourceModel, diag.Diagnostics) <span class="cov8" title="1">{
        state := plan
        state.ID = types.StringValue(sds.ID)
        state.Name = types.StringValue(sds.Name)
        state.Port = types.Int64Value(int64(sds.Port))
        state.SdsState = types.StringValue(sds.SdsState)
        state.MembershipState = types.StringValue(sds.MembershipState)
        state.MdmConnectionState = types.StringValue(sds.MdmConnectionState)
        state.DrlMode = types.StringValue(sds.DrlMode)
        state.RmcacheEnabled = types.BoolValue(sds.RmcacheEnabled)
        state.RmcacheSizeInMB = types.Int64Value(int64(sds.RmcacheSizeInKb) / 1024)
        state.RfcacheEnabled = types.BoolValue(sds.RfcacheEnabled)
        state.RmcacheFrozen = types.BoolValue(sds.RmcacheFrozen)
        state.IsOnVMware = types.BoolValue(sds.IsOnVMware)
        state.FaultSetID = types.StringValue(sds.FaultSetID)
        state.NumOfIoBuffers = types.Int64Value(int64(sds.NumOfIoBuffers))
        state.RmcacheMemoryAllocationState = types.StringValue(sds.RmcacheMemoryAllocationState)
        state.PerformanceProfile = types.StringValue(sds.PerformanceProfile)

        IPAttrTypes := map[string]attr.Type{
                "ip":   types.StringType,
                "role": types.StringType,
        }
        IPElemType := types.ObjectType{
                AttrTypes: IPAttrTypes,
        }

        objectIPs := []attr.Value{}
        var diags diag.Diagnostics
        for _, ip := range sds.IPList </span><span class="cov8" title="1">{
                obj := map[string]attr.Value{
                        "ip":   types.StringValue(ip.IP),
                        "role": types.StringValue(ip.Role),
                }
                objVal, dgs := types.ObjectValue(IPAttrTypes, obj)
                diags = append(diags, dgs...)
                objectIPs = append(objectIPs, objVal)
        }</span>
        <span class="cov8" title="1">setVal, dgs := types.SetValue(IPElemType, objectIPs)
        diags = append(diags, dgs...)
        state.IPList = setVal

        return state, diags</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package powerflex

import (
        "context"

        "github.com/dell/goscaleio"
        scaleiotypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ datasource.DataSource              = &amp;snapshotPolicyDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;snapshotPolicyDataSource{}
)

// SnapshotPolicyDataSource returns the snapshot policy data source
func SnapshotPolicyDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;snapshotPolicyDataSource{}
}</span>

type snapshotPolicyDataSource struct {
        client *goscaleio.Client
}

type snapshotPolicyDataSourceModel struct {
        SnapshotPolicies []snapshotPolicyModel `tfsdk:"snapshotpolicies"`
        ID               types.String          `tfsdk:"id"`
        Name             types.String          `tfsdk:"name"`
}

type snapshotPolicyModel struct {
        ID                                    types.String              `tfsdk:"id"`
        Name                                  types.String              `tfsdk:"name"`
        SnapshotPolicyState                   types.String              `tfsdk:"snapshot_policy_state"`
        AutoSnapshotCreationCadenceInMin      types.Int64               `tfsdk:"auto_snapshot_creation_cadence_in_min"`
        MaxVTreeAutoSnapshots                 types.Int64               `tfsdk:"max_vtree_auto_snapshots"`
        NumOfSourceVolumes                    types.Int64               `tfsdk:"num_of_source_volumes"`
        NumOfExpiredButLockedSnapshots        types.Int64               `tfsdk:"num_of_expired_but_locked_snapshots"`
        NumOfCreationFailures                 types.Int64               `tfsdk:"num_of_creation_failures"`
        NumOfRetainedSnapshotsPerLevel        []types.Int64             `tfsdk:"num_of_retained_snapshots_per_level"`
        SnapshotAccessMode                    types.String              `tfsdk:"snapshot_access_mode"`
        SecureSnapshots                       types.Bool                `tfsdk:"secure_snapshots"`
        TimeOfLastAutoSnapshot                types.Int64               `tfsdk:"time_of_last_auto_snapshot"`
        NextAutoSnapshotCreationTime          types.Int64               `tfsdk:"next_auto_snapshot_creation_time"`
        TimeOfLastAutoSnapshotCreationFailure types.Int64               `tfsdk:"time_of_last_auto_snapshot_creation_failure"`
        LastAutoSnapshotCreationFailureReason types.String              `tfsdk:"last_auto_snapshot_creation_failure_reason"`
        LastAutoSnapshotFailureInFirstLevel   types.Bool                `tfsdk:"last_auto_snapshot_failure_in_first_level"`
        NumOfAutoSnapshots                    types.Int64               `tfsdk:"num_of_auto_snapshots"`
        NumOfLockedSnapshots                  types.Int64               `tfsdk:"num_of_locked_snapshots"`
        SystemID                              types.String              `tfsdk:"system_id"`
        Links                                 []snapshotPolicyLinkModel `tfsdk:"links"`
}

type snapshotPolicyLinkModel struct {
        Rel  types.String `tfsdk:"rel"`
        HREF types.String `tfsdk:"href"`
}

func (d *snapshotPolicyDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_snapshotpolicy"
}</span>

func (d *snapshotPolicyDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = SnapshotPolicyDataSourceSchema
}</span>

func (d *snapshotPolicyDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">d.client = req.ProviderData.(*goscaleio.Client)</span>
}

func (d *snapshotPolicyDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var plan snapshotPolicyDataSourceModel
        var sps []*scaleiotypes.SnapshotPolicy
        var err error

        diags := req.Config.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        //Read the snapshot policies based on snapshot policy id/name and if nothing
        //is mentioned , then returns all the snapshot policies
        <span class="cov8" title="1">if plan.Name.ValueString() != "" </span><span class="cov8" title="1">{
                sps, err = d.client.GetSnapshotPolicy(plan.Name.ValueString(), "")
        }</span> else<span class="cov8" title="1"> if plan.ID.ValueString() != "" </span><span class="cov8" title="1">{
                sps, err = d.client.GetSnapshotPolicy("", plan.ID.ValueString())
        }</span> else<span class="cov8" title="1"> {
                sps, err = d.client.GetSnapshotPolicy("", "")
        }</span>
        //check if there is any error while getting the snapshot policy
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex Snapshot Policy",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">plan.SnapshotPolicies = updateSnapshotPolicyState(sps)
        plan.ID = types.StringValue("dummyID")
        diags = resp.State.Set(ctx, plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// updateSnapshotPolicyState iterates over the snapshotpolicy list and update the state
func updateSnapshotPolicyState(sps []*scaleiotypes.SnapshotPolicy) (response []snapshotPolicyModel) <span class="cov8" title="1">{
        for _, sp := range sps </span><span class="cov8" title="1">{
                spState := snapshotPolicyModel{
                        ID:                                    types.StringValue(sp.ID),
                        Name:                                  types.StringValue(sp.Name),
                        SnapshotPolicyState:                   types.StringValue(sp.SnapshotPolicyState),
                        AutoSnapshotCreationCadenceInMin:      types.Int64Value((int64)(sp.AutoSnapshotCreationCadenceInMin)),
                        MaxVTreeAutoSnapshots:                 types.Int64Value((int64)(sp.MaxVTreeAutoSnapshots)),
                        NumOfSourceVolumes:                    types.Int64Value((int64)(sp.NumOfSourceVolumes)),
                        NumOfExpiredButLockedSnapshots:        types.Int64Value((int64)(sp.NumOfExpiredButLockedSnapshots)),
                        NumOfCreationFailures:                 types.Int64Value((int64)(sp.NumOfCreationFailures)),
                        SnapshotAccessMode:                    types.StringValue(sp.SnapshotAccessMode),
                        SecureSnapshots:                       types.BoolValue(sp.SecureSnapshots),
                        TimeOfLastAutoSnapshot:                types.Int64Value((int64)(sp.TimeOfLastAutoSnapshot)),
                        NextAutoSnapshotCreationTime:          types.Int64Value((int64)(sp.NextAutoSnapshotCreationTime)),
                        TimeOfLastAutoSnapshotCreationFailure: types.Int64Value((int64)(sp.TimeOfLastAutoSnapshotCreationFailure)),
                        LastAutoSnapshotCreationFailureReason: types.StringValue(sp.LastAutoSnapshotCreationFailureReason),
                        LastAutoSnapshotFailureInFirstLevel:   types.BoolValue(sp.LastAutoSnapshotFailureInFirstLevel),
                        NumOfAutoSnapshots:                    types.Int64Value((int64)(sp.NumOfAutoSnapshots)),
                        NumOfLockedSnapshots:                  types.Int64Value((int64)(sp.NumOfLockedSnapshots)),
                        SystemID:                              types.StringValue(sp.SystemID),
                }

                for _, link := range sp.Links </span><span class="cov8" title="1">{
                        spState.Links = append(spState.Links, snapshotPolicyLinkModel{
                                Rel:  types.StringValue(link.Rel),
                                HREF: types.StringValue(link.HREF),
                        })
                }</span>
                <span class="cov8" title="1">for _, rspl := range sp.NumOfRetainedSnapshotsPerLevel </span><span class="cov8" title="1">{
                        spState.NumOfRetainedSnapshotsPerLevel = append(spState.NumOfRetainedSnapshotsPerLevel, types.Int64Value((int64)(rspl)))
                }</span>
                <span class="cov8" title="1">response = append(response, spState)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package powerflex

import (
        "context"

        "github.com/dell/goscaleio"
        scaleio_types "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ datasource.DataSource              = &amp;storagepoolDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;storagepoolDataSource{}
)

// StoragePoolDataSource is a helper function to simplify the provider implementation.
func StoragePoolDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;storagepoolDataSource{}
}</span>

// storagepoolDataSource is the data source implementation.
type storagepoolDataSource struct {
        client *goscaleio.Client
}

// volume maps the volume schema data.
type volume struct {
        ID   types.String `tfsdk:"id"`
        Name types.String `tfsdk:"name"`
}

// sdsData maps the SDS schema data
type sdsData struct {
        ID   types.String `tfsdk:"id"`
        Name types.String `tfsdk:"name"`
}

// linkModel maps the link schema data
type linkModel struct {
        Rel  types.String `tfsdk:"rel"`
        HREF types.String `tfsdk:"href"`
}

// storagePoolModel maps the storagepool schema data
type storagePoolModel struct {
        ID                                                            types.String `tfsdk:"id"`
        Name                                                          types.String `tfsdk:"name"`
        RebalanceioPriorityPolicy                                     types.String `tfsdk:"rebalance_io_priority_policy"`
        RebuildioPriorityPolicy                                       types.String `tfsdk:"rebuild_io_priority_policy"`
        RebuildioPriorityBwLimitPerDeviceInKbps                       types.Int64  `tfsdk:"rebuild_io_priority_bw_limit_per_device_in_kbps"`
        RebuildioPriorityNumOfConcurrentIosPerDevice                  types.Int64  `tfsdk:"rebuild_io_priority_num_of_concurrent_ios_per_device"`
        RebalanceioPriorityNumOfConcurrentIosPerDevice                types.Int64  `tfsdk:"rebalance_io_priority_num_of_concurrent_ios_per_device"`
        RebalanceioPriorityBwLimitPerDeviceInKbps                     types.Int64  `tfsdk:"rebalance_io_priority_bw_limit_per_device_kbps"`
        RebuildioPriorityAppIopsPerDeviceThreshold                    types.Int64  `tfsdk:"rebuild_io_priority_app_iops_per_device_threshold"`
        RebalanceioPriorityAppIopsPerDeviceThreshold                  types.Int64  `tfsdk:"rebalance_io_priority_app_iops_per_device_threshold"`
        RebuildioPriorityAppBwPerDeviceThresholdInKbps                types.Int64  `tfsdk:"rebuild_io_priority_app_bw_per_device_threshold_kbps"`
        RebalanceioPriorityAppBwPerDeviceThresholdInKbps              types.Int64  `tfsdk:"rebalance_io_priority_app_bw_per_device_threshold_kbps"`
        RebuildioPriorityQuietPeriodInMsec                            types.Int64  `tfsdk:"rebuild_io_priority_quiet_period_msec"`
        RebalanceioPriorityQuietPeriodInMsec                          types.Int64  `tfsdk:"rebalance_io_priority_quiet_period_msec"`
        ZeroPaddingEnabled                                            types.Bool   `tfsdk:"zero_padding_enabled"`
        UseRmcache                                                    types.Bool   `tfsdk:"use_rm_cache"`
        SparePercentage                                               types.Int64  `tfsdk:"spare_percentage"`
        RmCacheWriteHandlingMode                                      types.String `tfsdk:"rm_cache_write_handling_mode"`
        RebuildEnabled                                                types.Bool   `tfsdk:"rebuild_enabled"`
        RebalanceEnabled                                              types.Bool   `tfsdk:"rebalance_enabled"`
        NumofParallelRebuildRebalanceJobsPerDevice                    types.Int64  `tfsdk:"num_of_parallel_rebuild_rebalance_jobs_per_device"`
        BackgroundScannerBWLimitKBps                                  types.Int64  `tfsdk:"background_scanner_bw_limit_kbps"`
        ProtectedMaintenanceModeIoPriorityNumOfConcurrentIosPerDevice types.Int64  `tfsdk:"protected_maintenance_mode_io_priority_num_of_concurrent_ios_per_device"`
        DataLayout                                                    types.String `tfsdk:"data_layout"`
        VtreeMigrationIoPriorityBwLimitPerDeviceInKbps                types.Int64  `tfsdk:"vtree_migration_io_priority_bw_limit_per_device_kbps"`
        VtreeMigrationIoPriorityPolicy                                types.String `tfsdk:"vtree_migration_io_priority_policy"`
        AddressSpaceUsage                                             types.String `tfsdk:"address_space_usage"`
        ExternalAccelerationType                                      types.String `tfsdk:"external_acceleration_type"`
        PersistentChecksumState                                       types.String `tfsdk:"persistent_checksum_state"`
        UseRfcache                                                    types.Bool   `tfsdk:"use_rf_cache"`
        ChecksumEnabled                                               types.Bool   `tfsdk:"checksum_enabled"`
        CompressionMethod                                             types.String `tfsdk:"compression_method"`
        FragmentationEnabled                                          types.Bool   `tfsdk:"fragmentation_enabled"`
        CapacityUsageState                                            types.String `tfsdk:"capacity_usage_state"`
        CapacityUsageType                                             types.String `tfsdk:"capacity_usage_type"`
        AddressSpaceUsageType                                         types.String `tfsdk:"address_space_usage_type"`
        BgScannerCompareErrorAction                                   types.String `tfsdk:"bg_scanner_compare_error_action"`
        BgScannerReadErrorAction                                      types.String `tfsdk:"bg_scanner_read_error_action"`
        ReplicationCapacityMaxRatio                                   types.Int64  `tfsdk:"replication_capacity_max_ratio"`
        PersistentChecksumEnabled                                     types.Bool   `tfsdk:"persistent_checksum_enabled"`
        PersistentChecksumBuilderLimitKb                              types.Int64  `tfsdk:"persistent_checksum_builder_limit_kb"`
        PersistentChecksumValidateOnRead                              types.Bool   `tfsdk:"persistent_checksum_validate_on_read"`
        VtreeMigrationIoPriorityNumOfConcurrentIosPerDevice           types.Int64  `tfsdk:"vtree_migration_io_priority_num_of_concurrent_ios_per_device"`
        ProtectedMaintenanceModeIoPriorityPolicy                      types.String `tfsdk:"protected_maintenance_mode_io_priority_policy"`
        BackgroundScannerMode                                         types.String `tfsdk:"background_scanner_mode"`
        MediaType                                                     types.String `tfsdk:"media_type"`
        Volumes                                                       []volume     `tfsdk:"volumes"`
        SDS                                                           []sdsData    `tfsdk:"sds"`
        Links                                                         []linkModel  `tfsdk:"links"`
}

// storagepoolDataSourceModel maps the storage pool data source schema data
type storagepoolDataSourceModel struct {
        StoragePoolIDs       types.List         `tfsdk:"storage_pool_ids"`
        StoragePoolNames     types.List         `tfsdk:"storage_pool_names"`
        ProtectionDomainID   types.String       `tfsdk:"protection_domain_id"`
        ProtectionDomainName types.String       `tfsdk:"protection_domain_name"`
        StoragePools         []storagePoolModel `tfsdk:"storage_pools"`
        ID                   types.String       `tfsdk:"id"`
}

// Metadata returns the data source type name.
func (d *storagepoolDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_storagepool"
}</span>

// Schema defines the schema for the data source.
func (d *storagepoolDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = DataSourceSchema
}</span>

// Configure adds the provider configured client to the data source.
func (d *storagepoolDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">d.client = req.ProviderData.(*goscaleio.Client)</span>
}

// Read refreshes the Terraform state with the latest data.
func (d *storagepoolDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        tflog.Info(ctx, "Started storage pool data source read method")
        var state storagepoolDataSourceModel
        var pd *scaleio_types.ProtectionDomain
        var err3 error

        diags := req.Config.Get(ctx, &amp;state)

        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get the systems on the PowerFlex cluster
        <span class="cov8" title="1">c2, err := getFirstSystem(d.client)
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error in getting system instance",
                        err.Error(),
                )
                return
        }</span>

        // Check if protection domain ID or name is provided
        <span class="cov8" title="1">if state.ProtectionDomainID.ValueString() != "" </span><span class="cov8" title="1">{
                pd, err3 = c2.FindProtectionDomain(state.ProtectionDomainID.ValueString(), "", "")
        }</span> else<span class="cov8" title="1"> {
                pd, err3 = c2.FindProtectionDomain("", state.ProtectionDomainName.ValueString(), "")
        }</span>

        <span class="cov8" title="1">if err3 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to find protection domain",
                        err3.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">p1 := goscaleio.NewProtectionDomainEx(d.client, pd)

        sp := goscaleio.NewStoragePool(d.client)

        spID := []string{}
        // Check if storage pool ID or name is provided
        if !state.StoragePoolIDs.IsNull() </span><span class="cov8" title="1">{
                diags = state.StoragePoolIDs.ElementsAs(ctx, &amp;spID, true)
        }</span> else<span class="cov8" title="1"> if !state.StoragePoolNames.IsNull() </span><span class="cov8" title="1">{
                diags = state.StoragePoolNames.ElementsAs(ctx, &amp;spID, true)
        }</span> else<span class="cov8" title="1"> {
                // Get all the storage pools associated with protection domain
                storagePools, _ := p1.GetStoragePool("")
                for sp := range storagePools </span><span class="cov8" title="1">{
                        spID = append(spID, storagePools[sp].Name)
                }</span>
        }

        <span class="cov8" title="1">if numSP := len(spID); numSP == 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError("No storage pools found for the specified protection domain", "")
                return
        }</span>

        <span class="cov8" title="1">if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
                return
        }</span>

        <span class="cov8" title="1">for _, spIdentifier := range spID </span><span class="cov8" title="1">{
                var s1 *scaleio_types.StoragePool

                if !state.StoragePoolIDs.IsNull() </span><span class="cov8" title="1">{
                        s1, err3 = p1.FindStoragePool(spIdentifier, "", "")
                }</span> else<span class="cov8" title="1"> {
                        s1, err3 = p1.FindStoragePool("", spIdentifier, "")
                }</span>

                <span class="cov8" title="1">if err3 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to read storage pool",
                                err3.Error(),
                        )
                        return
                }</span>
                <span class="cov8" title="1">sp.StoragePool = s1

                volList, err4 := sp.GetVolume("", "", "", "", false)
                if err4 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to get volumes associated with storage pool",
                                err4.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">sdsList, err5 := sp.GetSDSStoragePool()
                if err5 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to get SDS associated with storage pool",
                                err5.Error(),
                        )
                        return
                }</span>

                <span class="cov8" title="1">storagePool := getStoragePoolState(volList, sdsList, s1)
                state.StoragePools = append(state.StoragePools, storagePool)</span>
        }

        // this is required for acceptance testing
        <span class="cov8" title="1">state.ID = types.StringValue("dummyID")

        // Set state
        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

func getStoragePoolState(volList []*scaleio_types.Volume, sdsList []scaleio_types.Sds, s1 *scaleio_types.StoragePool) (storagePool storagePoolModel) <span class="cov8" title="1">{
        storagePool = storagePoolModel{
                ID:   types.StringValue(s1.ID),
                Name: types.StringValue(s1.Name),
        }

        // Iterate through volume list
        for _, vol := range volList </span><span class="cov8" title="1">{
                storagePool.Volumes = append(storagePool.Volumes, volume{
                        ID:   types.StringValue(vol.ID),
                        Name: types.StringValue(vol.Name),
                })
        }</span>

        // Iterate through SDS list
        <span class="cov8" title="1">for _, sds := range sdsList </span><span class="cov8" title="1">{
                storagePool.SDS = append(storagePool.SDS, sdsData{
                        ID:   types.StringValue(sds.ID),
                        Name: types.StringValue(sds.Name),
                })
        }</span>

        // Iterate through the Links
        <span class="cov8" title="1">for _, link := range s1.Links </span><span class="cov8" title="1">{
                storagePool.Links = append(storagePool.Links, linkModel{
                        Rel:  types.StringValue(link.Rel),
                        HREF: types.StringValue(link.HREF),
                })
        }</span>

        <span class="cov8" title="1">storagePool.RebalanceioPriorityPolicy = types.StringValue(s1.RebalanceioPriorityPolicy)
        storagePool.RebalanceioPriorityAppBwPerDeviceThresholdInKbps = types.Int64Value(int64(s1.RebalanceioPriorityAppBwPerDeviceThresholdInKbps))
        storagePool.RebalanceioPriorityAppIopsPerDeviceThreshold = types.Int64Value(int64(s1.RebalanceioPriorityAppIopsPerDeviceThreshold))
        storagePool.RebalanceioPriorityBwLimitPerDeviceInKbps = types.Int64Value(int64(s1.RebalanceioPriorityBwLimitPerDeviceInKbps))
        storagePool.RebalanceioPriorityQuietPeriodInMsec = types.Int64Value(int64(s1.RebalanceioPriorityQuietPeriodInMsec))
        storagePool.RebalanceioPriorityNumOfConcurrentIosPerDevice = types.Int64Value(int64(s1.RebalanceioPriorityNumOfConcurrentIosPerDevice))
        storagePool.RebuildioPriorityPolicy = types.StringValue(s1.RebuildioPriorityPolicy)
        storagePool.RebuildioPriorityAppBwPerDeviceThresholdInKbps = types.Int64Value(int64(s1.RebuildioPriorityAppBwPerDeviceThresholdInKbps))
        storagePool.RebuildioPriorityAppIopsPerDeviceThreshold = types.Int64Value(int64(s1.RebuildioPriorityAppIopsPerDeviceThreshold))
        storagePool.RebuildioPriorityBwLimitPerDeviceInKbps = types.Int64Value(int64(s1.RebalanceioPriorityBwLimitPerDeviceInKbps))
        storagePool.RebuildioPriorityQuietPeriodInMsec = types.Int64Value(int64(s1.RebuildioPriorityQuietPeriodInMsec))
        storagePool.RebuildioPriorityNumOfConcurrentIosPerDevice = types.Int64Value(int64(s1.RebuildioPriorityNumOfConcurrentIosPerDevice))
        storagePool.ZeroPaddingEnabled = types.BoolValue(s1.ZeroPaddingEnabled)
        storagePool.UseRmcache = types.BoolValue(s1.UseRmcache)
        storagePool.SparePercentage = types.Int64Value(int64(s1.SparePercentage))
        storagePool.RmCacheWriteHandlingMode = types.StringValue(s1.RmCacheWriteHandlingMode)
        storagePool.RebalanceEnabled = types.BoolValue(s1.RebalanceEnabled)
        storagePool.RebuildEnabled = types.BoolValue(s1.RebuildEnabled)
        storagePool.NumofParallelRebuildRebalanceJobsPerDevice = types.Int64Value(int64(s1.NumofParallelRebuildRebalanceJobsPerDevice))
        storagePool.BackgroundScannerBWLimitKBps = types.Int64Value(int64(s1.BackgroundScannerBWLimitKBps))
        storagePool.ProtectedMaintenanceModeIoPriorityNumOfConcurrentIosPerDevice = types.Int64Value(int64(s1.ProtectedMaintenanceModeIoPriorityNumOfConcurrentIosPerDevice))
        storagePool.DataLayout = types.StringValue(s1.DataLayout)
        storagePool.VtreeMigrationIoPriorityBwLimitPerDeviceInKbps = types.Int64Value(int64(s1.VtreeMigrationIoPriorityBwLimitPerDeviceInKbps))
        storagePool.VtreeMigrationIoPriorityPolicy = types.StringValue(s1.VtreeMigrationIoPriorityPolicy)
        storagePool.AddressSpaceUsage = types.StringValue(s1.AddressSpaceUsage)
        storagePool.ExternalAccelerationType = types.StringValue(s1.ExternalAccelerationType)
        storagePool.PersistentChecksumState = types.StringValue(s1.PersistentChecksumState)
        storagePool.UseRfcache = types.BoolValue(s1.UseRfcache)
        storagePool.ChecksumEnabled = types.BoolValue(s1.ChecksumEnabled)
        storagePool.CompressionMethod = types.StringValue(s1.CompressionMethod)
        storagePool.FragmentationEnabled = types.BoolValue(s1.FragmentationEnabled)
        storagePool.CapacityUsageState = types.StringValue(s1.CapacityUsageState)
        storagePool.CapacityUsageType = types.StringValue(s1.CapacityUsageType)
        storagePool.AddressSpaceUsageType = types.StringValue(s1.AddressSpaceUsageType)
        storagePool.BgScannerCompareErrorAction = types.StringValue(s1.BgScannerCompareErrorAction)
        storagePool.BgScannerReadErrorAction = types.StringValue(s1.BgScannerReadErrorAction)
        storagePool.ReplicationCapacityMaxRatio = types.Int64Value(int64(s1.ReplicationCapacityMaxRatio))
        storagePool.PersistentChecksumEnabled = types.BoolValue(s1.PersistentChecksumEnabled)
        storagePool.PersistentChecksumBuilderLimitKb = types.Int64Value(int64(s1.PersistentChecksumBuilderLimitKb))
        storagePool.PersistentChecksumValidateOnRead = types.BoolValue(s1.PersistentChecksumValidateOnRead)
        storagePool.VtreeMigrationIoPriorityNumOfConcurrentIosPerDevice = types.Int64Value(int64(s1.VtreeMigrationIoPriorityNumOfConcurrentIosPerDevice))
        storagePool.ProtectedMaintenanceModeIoPriorityPolicy = types.StringValue(s1.ProtectedMaintenanceModeIoPriorityPolicy)
        storagePool.BackgroundScannerMode = types.StringValue(s1.BackgroundScannerMode)
        storagePool.MediaType = types.StringValue(s1.MediaType)
        return</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package powerflex

import (
        "context"
        "terraform-provider-powerflex/helper"

        "github.com/dell/goscaleio"
        scaleiotypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
        "github.com/hashicorp/terraform-plugin-log/tflog"
)

var (
        _ resource.Resource                = &amp;storagepoolResource{}
        _ resource.ResourceWithConfigure   = &amp;storagepoolResource{}
        _ resource.ResourceWithImportState = &amp;storagepoolResource{}
)

// StoragepoolResource - function to return resource interface
func StoragepoolResource() resource.Resource <span class="cov8" title="1">{
        return &amp;storagepoolResource{}
}</span>

type storagepoolResource struct {
        client *goscaleio.Client
}

type storagepoolResourceModel struct {
        LastUpdated          types.String `tfsdk:"last_updated"`
        ID                   types.String `tfsdk:"id"`
        SystemID             types.String `tfsdk:"systemid"`
        ProtectionDomainID   types.String `tfsdk:"protection_domain_id"`
        ProtectionDomainName types.String `tfsdk:"protection_domain_name"`
        Name                 types.String `tfsdk:"name"`
        MediaType            types.String `tfsdk:"media_type"`
        UseRmcache           types.Bool   `tfsdk:"use_rmcache"`
        UseRfcache           types.Bool   `tfsdk:"use_rfcache"`
        Links                types.List   `tfsdk:"links"`
}

// Link - MODEL for Storagepool Links data returned by goscaleio.
type Link struct {
        Rel  types.String `tfsdk:"rel"`
        HREF types.String `tfsdk:"href"`
}

func (r *storagepoolResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_storagepool"
}</span>

func (r *storagepoolResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = StoragepoolReourceSchema
}</span>

func (r *storagepoolResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">r.client = req.ProviderData.(*goscaleio.Client)</span>
}

// getNewProtectionDomainEx function to get Protection Domain
func getNewProtectionDomainEx(c *goscaleio.Client, pdID string, pdName string, href string) (*goscaleio.ProtectionDomain, error) <span class="cov8" title="1">{
        system, _ := getFirstSystem(c)
        pdr := goscaleio.NewProtectionDomainEx(c, &amp;scaleiotypes.ProtectionDomain{})
        if pdID != "" </span><span class="cov8" title="1">{
                protectionDomain, err := system.FindProtectionDomain(pdID, "", "")
                pdr.ProtectionDomain = protectionDomain
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                protectionDomain, err := system.FindProtectionDomain("", pdName, "")
                pdr.ProtectionDomain = protectionDomain
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return pdr, nil</span>
}

// Function used to Create Storagepool Resource
func (r *storagepoolResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "Create storagepool")
        // Retrieve values from plan
        var plan storagepoolResourceModel

        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pd, err := getNewProtectionDomainEx(r.client, plan.ProtectionDomainID.ValueString(), plan.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        "Could not get Protection Domain, unexpected err: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">sp, err := pd.CreateStoragePool(plan.Name.ValueString(), plan.MediaType.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error creating Storage Pool",
                        "Could not create Storage Pool, unexpected error: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">spResponse, err := pd.FindStoragePool(sp, "", "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting Storagepool after creation",
                        "Could not get Storagepool, unexpected error: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">if plan.UseRmcache.ValueBool() </span><span class="cov8" title="1">{
                rm := goscaleio.NewStoragePoolEx(r.client, spResponse)
                rm.ModifyRMCache("true")
        }</span> else<span class="cov8" title="1"> {
                rm := goscaleio.NewStoragePoolEx(r.client, spResponse)
                rm.ModifyRMCache("false")
        }</span>

        <span class="cov8" title="1">if plan.UseRfcache.ValueBool() </span><span class="cov8" title="1">{
                _, err := pd.EnableRFCache(sp)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error getting while updating Storagepool",
                                "Could not get Storagepool, unexpected error: "+err.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">state := updateStoragepoolState(spResponse, plan)
        tflog.Debug(ctx, "Create Storagepool :-- "+helper.PrettyJSON(sp))
        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Function used to Read Storagepool Resource
func (r *storagepoolResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "Read Storagepool")
        // Get current state
        var state storagepoolResourceModel

        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pd, err := getNewProtectionDomainEx(r.client, state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        "Could not get Protection Domain, unexpected err: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">spr, err := pd.FindStoragePool(state.ID.ValueString(), "", "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex Storagepool",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">spResponse := updateStoragepoolState(spr, state)
        tflog.Debug(ctx, "Read Storagepool :-- "+helper.PrettyJSON(spr))
        diags = resp.State.Set(ctx, spResponse)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Function used to Update Storagepool Resource
func (r *storagepoolResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "Update Storagepool")
        // Retrieve values from plan
        var plan storagepoolResourceModel

        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        //Get Current State
        <span class="cov8" title="1">var state storagepoolResourceModel
        diags = req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pd, err := getNewProtectionDomainEx(r.client, plan.ProtectionDomainID.ValueString(), plan.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        "Could not get Protection Domain, unexpected err: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">if plan.Name.ValueString() != state.Name.ValueString() </span><span class="cov8" title="1">{
                _, err := pd.ModifyStoragePoolName(state.ID.ValueString(), plan.Name.ValueString())
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error getting while updating Storagepool",
                                "Could not get Storagepool, unexpected error: "+err.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">if plan.MediaType.ValueString() != state.MediaType.ValueString() </span><span class="cov8" title="1">{
                _, err := pd.ModifyStoragePoolMedia(state.ID.ValueString(), plan.MediaType.ValueString())
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error getting while updating Storagepool",
                                "Could not get Storagepool, unexpected error: "+err.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">spResponse, err := pd.FindStoragePool(state.ID.ValueString(), "", "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting while updating Storagepool",
                        "Could not get Storagepool, unexpected error: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">if plan.UseRmcache.ValueBool() </span><span class="cov8" title="1">{
                rm := goscaleio.NewStoragePoolEx(r.client, spResponse)
                rm.ModifyRMCache("true")
        }</span> else<span class="cov8" title="1"> {
                rm := goscaleio.NewStoragePoolEx(r.client, spResponse)
                rm.ModifyRMCache("false")
        }</span>

        <span class="cov8" title="1">if plan.UseRfcache.ValueBool() </span><span class="cov8" title="1">{
                _, err := pd.EnableRFCache(spResponse.ID)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error getting while updating Storagepool",
                                "Could not get Storagepool, unexpected error: "+err.Error(),
                        )
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                _, err := pd.DisableRFCache(spResponse.ID)
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error getting while updating Storagepool",
                                "Could not get Storagepool, unexpected error: "+err.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov8" title="1">state1 := updateStoragepoolState(spResponse, plan)
        tflog.Debug(ctx, "Update Storagepool :-- "+helper.PrettyJSON(spResponse))
        diags = resp.State.Set(ctx, state1)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Function used to Delete Storagepool Resource
func (r *storagepoolResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov8" title="1">{
        tflog.Debug(ctx, "Delete Storagepool")
        // Retrieve values from state
        var state storagepoolResourceModel

        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">pd, err := getNewProtectionDomainEx(r.client, state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString(), "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting Protection Domain",
                        "Could not get Protection Domain, unexpected err: "+err.Error(),
                )
                return
        }</span>

        <span class="cov8" title="1">spr, err := r.client.FindStoragePool(state.ID.ValueString(), "", "", "")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Find Powerflex Storagepool",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">err = pd.DeleteStoragePool(state.Name.ValueString())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error Deleting Storagepool",
                        "Couldn't Delete Storagepool "+err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">tflog.Debug(ctx, "Delete Storagepool :-- "+helper.PrettyJSON(spr))
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">resp.State.RemoveResource(ctx)</span>
}

// Function used to ImportState for Storagepool Resource
func (r *storagepoolResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov8" title="1">{
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>

// Function to update the State for Storagepool Resource
func updateStoragepoolState(storagepool *scaleiotypes.StoragePool, plan storagepoolResourceModel) (state storagepoolResourceModel) <span class="cov8" title="1">{
        state.ProtectionDomainID = plan.ProtectionDomainID
        state.ProtectionDomainName = plan.ProtectionDomainName
        state.ID = types.StringValue(storagepool.ID)
        state.Name = types.StringValue(storagepool.Name)
        state.MediaType = types.StringValue(storagepool.MediaType)
        state.UseRmcache = types.BoolValue(plan.UseRmcache.ValueBool())
        state.UseRfcache = types.BoolValue(plan.UseRfcache.ValueBool())

        linkAttrTypes := map[string]attr.Type{
                "rel":  types.StringType,
                "href": types.StringType,
        }
        linkElemType := types.ObjectType{
                AttrTypes: linkAttrTypes,
        }

        objectLinks := []attr.Value{}
        for _, link := range storagepool.Links </span><span class="cov8" title="1">{
                obj := map[string]attr.Value{
                        "rel":  types.StringValue(link.Rel),
                        "href": types.StringValue(link.HREF),
                }
                objVal, _ := types.ObjectValue(linkAttrTypes, obj)
                objectLinks = append(objectLinks, objVal)
        }</span>
        <span class="cov8" title="1">listVal, _ := types.ListValue(linkElemType, objectLinks)
        state.Links = listVal
        return state</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package powerflex

import (
        "context"

        "github.com/dell/goscaleio"
        scaleiotypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/datasource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

var (
        _ datasource.DataSource              = &amp;volumeDataSource{}
        _ datasource.DataSourceWithConfigure = &amp;volumeDataSource{}
)

// VolumeDataSource returns the volume data source
func VolumeDataSource() datasource.DataSource <span class="cov8" title="1">{
        return &amp;volumeDataSource{}
}</span>

type volumeDataSource struct {
        client *goscaleio.Client
}

type volumeDataSourceModel struct {
        Volumes         []volumeModel `tfsdk:"volumes"`
        ID              types.String  `tfsdk:"id"`
        StoragePoolID   types.String  `tfsdk:"storage_pool_id"`
        StoragePoolName types.String  `tfsdk:"storage_pool_name"`
        Name            types.String  `tfsdk:"name"`
}

type volumeModel struct {
        ID                                 types.String         `tfsdk:"id"`
        Name                               types.String         `tfsdk:"name"`
        CreationTime                       types.Int64          `tfsdk:"creation_time"`
        SizeInKb                           types.Int64          `tfsdk:"size_in_kb"`
        AncestorVolumeID                   types.String         `tfsdk:"ancestor_volume_id"`
        VTreeID                            types.String         `tfsdk:"vtree_id"`
        ConsistencyGroupID                 types.String         `tfsdk:"consistency_group_id"`
        VolumeType                         types.String         `tfsdk:"volume_type"`
        UseRmCache                         types.Bool           `tfsdk:"use_rm_cache"`
        StoragePoolID                      types.String         `tfsdk:"storage_pool_id"`
        DataLayout                         types.String         `tfsdk:"data_layout"`
        NotGenuineSnapshot                 types.Bool           `tfsdk:"not_genuine_snapshot"`
        AccessModeLimit                    types.String         `tfsdk:"access_mode_limit"`
        SecureSnapshotExpTime              types.Int64          `tfsdk:"secure_snapshot_exp_time"`
        ManagedBy                          types.String         `tfsdk:"managed_by"`
        LockedAutoSnapshot                 types.Bool           `tfsdk:"locked_auto_snapshot"`
        LockedAutoSnapshotMarkedForRemoval types.Bool           `tfsdk:"locked_auto_snapshot_marked_for_removal"`
        CompressionMethod                  types.String         `tfsdk:"compression_method"`
        TimeStampIsAccurate                types.Bool           `tfsdk:"time_stamp_is_accurate"`
        OriginalExpiryTime                 types.Int64          `tfsdk:"original_expiry_time"`
        VolumeReplicationState             types.String         `tfsdk:"volume_replication_state"`
        ReplicationJournalVolume           types.Bool           `tfsdk:"replication_journal_volume"`
        ReplicationTimeStamp               types.Int64          `tfsdk:"replication_time_stamp"`
        Links                              []volumeLinkModel    `tfsdk:"links"`
        MappedSdcInfo                      []mappedSdcInfoModel `tfsdk:"mapped_sdc_info"`
}

type volumeLinkModel struct {
        Rel  types.String `tfsdk:"rel"`
        HREF types.String `tfsdk:"href"`
}

type mappedSdcInfoModel struct {
        SdcID                 types.String `tfsdk:"sdc_id"`
        SdcIP                 types.String `tfsdk:"sdc_ip"`
        LimitIops             types.Int64  `tfsdk:"limit_iops"`
        LimitBwInMbps         types.Int64  `tfsdk:"limit_bw_in_mbps"`
        SdcName               types.String `tfsdk:"sdc_name"`
        AccessMode            types.String `tfsdk:"access_mode"`
        IsDirectBufferMapping types.Bool   `tfsdk:"is_direct_buffer_mapping"`
}

func (d *volumeDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_volume"
}</span>

func (d *volumeDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = VolumeDataSourceSchema
}</span>

func (d *volumeDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, _ *datasource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">d.client = req.ProviderData.(*goscaleio.Client)</span>
}

func (d *volumeDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) <span class="cov8" title="1">{
        var state volumeDataSourceModel
        var volumes []*scaleiotypes.Volume
        var err error

        diags := req.Config.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        //Read the volumes based on volume id/name or storage pool id/name and if nothing
        //is mentioned , then return all volumes
        <span class="cov8" title="1">if state.Name.ValueString() != "" </span><span class="cov8" title="1">{
                volumes, err = d.client.GetVolume("", "", "", state.Name.ValueString(), false)
        }</span> else<span class="cov8" title="1"> if state.ID.ValueString() != "" </span><span class="cov8" title="1">{
                volumes, err = d.client.GetVolume("", state.ID.ValueString(), "", "", false)
        }</span> else<span class="cov8" title="1"> if state.StoragePoolID.ValueString() != "" </span><span class="cov8" title="1">{
                sps, err1 := d.client.FindStoragePool(state.StoragePoolID.ValueString(), "", "", "")
                if err1 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to Read Powerflex Volumes",
                                err1.Error(),
                        )
                        return
                }</span>
                <span class="cov8" title="1">sp := goscaleio.NewStoragePool(d.client)
                sp.StoragePool = sps
                volumes, err = sp.GetVolume("", "", "", "", false)</span>
        } else<span class="cov8" title="1"> if state.StoragePoolName.ValueString() != "" </span><span class="cov8" title="1">{
                sps, err1 := d.client.FindStoragePool("", state.StoragePoolName.ValueString(), "", "")
                if err1 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Unable to Read Powerflex Volumes",
                                err1.Error(),
                        )
                        return
                }</span>
                <span class="cov8" title="1">sp := goscaleio.NewStoragePool(d.client)
                sp.StoragePool = sps
                volumes, err = sp.GetVolume("", "", "", "", false)</span>
        } else<span class="cov8" title="1"> {
                volumes, err = d.client.GetVolume("", "", "", "", false)
        }</span>
        //check if there is any error while getting the volume
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Unable to Read Powerflex Volumes",
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">state.Volumes = updateVolumeState(volumes)
        state.ID = types.StringValue("placeholder")
        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// updateVolumeState iterates over the volume list and update the state
func updateVolumeState(volumes []*scaleiotypes.Volume) (response []volumeModel) <span class="cov8" title="1">{
        for _, volumeValue := range volumes </span><span class="cov8" title="1">{
                volumeState := volumeModel{
                        ID:                                 types.StringValue(volumeValue.ID),
                        Name:                               types.StringValue(volumeValue.Name),
                        CreationTime:                       types.Int64Value((int64)(volumeValue.CreationTime)),
                        SizeInKb:                           types.Int64Value((int64)(volumeValue.SizeInKb)),
                        AncestorVolumeID:                   types.StringValue(volumeValue.AncestorVolumeID),
                        VTreeID:                            types.StringValue(volumeValue.VTreeID),
                        ConsistencyGroupID:                 types.StringValue(volumeValue.ConsistencyGroupID),
                        VolumeType:                         types.StringValue(volumeValue.VolumeType),
                        UseRmCache:                         types.BoolValue(volumeValue.UseRmCache),
                        StoragePoolID:                      types.StringValue(volumeValue.StoragePoolID),
                        DataLayout:                         types.StringValue(volumeValue.DataLayout),
                        NotGenuineSnapshot:                 types.BoolValue(volumeValue.NotGenuineSnapshot),
                        AccessModeLimit:                    types.StringValue(volumeValue.AccessModeLimit),
                        SecureSnapshotExpTime:              types.Int64Value((int64)(volumeValue.SecureSnapshotExpTime)),
                        ManagedBy:                          types.StringValue(volumeValue.ManagedBy),
                        LockedAutoSnapshot:                 types.BoolValue(volumeValue.LockedAutoSnapshot),
                        LockedAutoSnapshotMarkedForRemoval: types.BoolValue(volumeValue.LockedAutoSnapshotMarkedForRemoval),
                        CompressionMethod:                  types.StringValue(volumeValue.CompressionMethod),
                        TimeStampIsAccurate:                types.BoolValue(volumeValue.TimeStampIsAccurate),
                        OriginalExpiryTime:                 types.Int64Value((int64)(volumeValue.OriginalExpiryTime)),
                        VolumeReplicationState:             types.StringValue(volumeValue.VolumeReplicationState),
                        ReplicationJournalVolume:           types.BoolValue(volumeValue.ReplicationJournalVolume),
                        ReplicationTimeStamp:               types.Int64Value((int64)(volumeValue.ReplicationTimeStamp)),
                }

                for _, link := range volumeValue.Links </span><span class="cov8" title="1">{
                        volumeState.Links = append(volumeState.Links, volumeLinkModel{
                                Rel:  types.StringValue(link.Rel),
                                HREF: types.StringValue(link.HREF),
                        })
                }</span>
                <span class="cov8" title="1">for _, sdc := range volumeValue.MappedSdcInfo </span><span class="cov8" title="1">{
                        volumeState.MappedSdcInfo = append(volumeState.MappedSdcInfo, mappedSdcInfoModel{
                                SdcID:                 types.StringValue(sdc.SdcID),
                                SdcIP:                 types.StringValue(sdc.SdcIP),
                                LimitIops:             types.Int64Value((int64)(sdc.LimitIops)),
                                LimitBwInMbps:         types.Int64Value((int64)(sdc.LimitBwInMbps)),
                                SdcName:               types.StringValue(sdc.SdcName),
                                AccessMode:            types.StringValue(sdc.AccessMode),
                                IsDirectBufferMapping: types.BoolValue(sdc.IsDirectBufferMapping),
                        })
                }</span>
                <span class="cov8" title="1">response = append(response, volumeState)</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package powerflex

import (
        "context"
        "strconv"

        "github.com/dell/goscaleio"
        pftypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/path"
        "github.com/hashicorp/terraform-plugin-framework/resource"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

// Ensure the implementation satisfies the expected interfaces.
var (
        _ resource.Resource                = &amp;volumeResource{}
        _ resource.ResourceWithConfigure   = &amp;volumeResource{}
        _ resource.ResourceWithImportState = &amp;volumeResource{}
)

// NewVolumeResource is a helper function to simplify the provider implementation.
func NewVolumeResource() resource.Resource <span class="cov8" title="1">{
        return &amp;volumeResource{}
}</span>

// volumeResource is the resource implementation.
type volumeResource struct {
        client *goscaleio.Client
}

// Metadata returns the resource type name.
func (r *volumeResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) <span class="cov8" title="1">{
        resp.TypeName = req.ProviderTypeName + "_volume"
}</span>

// Schema defines the schema for the resource.
func (r *volumeResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) <span class="cov8" title="1">{
        resp.Schema = VolumeResourceSchema
}</span>

// Configure adds the provider configured client to the data source.
func (r *volumeResource) Configure(_ context.Context, req resource.ConfigureRequest, _ *resource.ConfigureResponse) <span class="cov8" title="1">{
        if req.ProviderData == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">r.client = req.ProviderData.(*goscaleio.Client)</span>
}

// Create creates the resource and sets the initial Terraform state.
func (r *volumeResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) <span class="cov8" title="1">{
        // Retrieve values from plan
        var plan VolumeResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if plan.Size.ValueInt64()%8 != 0 </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error: Size Must be in granularity of 8GB",
                        "Could not assign volume with size. sizeInGb ("+strconv.FormatInt(plan.Size.ValueInt64(), 10)+") must be a positive number in granularity of 8 GB.",
                )
                return
        }</span>
        <span class="cov8" title="1">VSIKB, err := convertToKB(plan.CapacityUnit.ValueString(), plan.Size.ValueInt64())
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error: Invalid Capacity unit :"+plan.CapacityUnit.String(),
                        err.Error(),
                )
                return
        }</span>
        <span class="cov8" title="1">volumeCreate := &amp;pftypes.VolumeParam{
                ProtectionDomainID: plan.ProtectionDomainID.ValueString(),
                StoragePoolID:      plan.StoragePoolID.ValueString(),
                UseRmCache:         strconv.FormatBool(plan.UseRmCache.ValueBool()),
                VolumeType:         plan.VolumeType.ValueString(),
                VolumeSizeInKb:     strconv.FormatInt(VSIKB, 10),
                Name:               plan.Name.ValueString(),
        }
        spr, _ := getStoragePoolInstance(r.client, volumeCreate.StoragePoolID, plan.StoragePoolName.ValueString(), volumeCreate.ProtectionDomainID, plan.ProtectionDomainName.ValueString())
        volCreateResponse, err1 := spr.CreateVolume(volumeCreate)
        if err1 != nil </span><span class="cov8" title="1">{
                resp.Diagnostics.AddError(
                        "Error creating volume",
                        "Could not create volume, unexpected error: "+err1.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">volsResponse, err2 := spr.GetVolume("", volCreateResponse.ID, "", "", false)
        if err2 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting volume after creation",
                        "Could not get volume, unexpected error: "+err2.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">vol := volsResponse[0]
        vr := goscaleio.NewVolume(r.client)
        vr.Volume = vol
        msids := []string{}
        diags = plan.MapSdcsID.ElementsAs(ctx, &amp;msids, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
        }</span>
        <span class="cov0" title="0">for _, msid := range msids </span><span class="cov0" title="0">{
                // Add mapped SDC
                pfmvsp := pftypes.MapVolumeSdcParam{
                        SdcID:                 msid,
                        AllowMultipleMappings: "true",
                }
                err3 := vr.MapVolumeSdc(&amp;pfmvsp)
                if err3 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error Mapping Volume to SDCs",
                                "Could not map volume to scs with id: "+msid+", unexpected error: "+err3.Error(),
                        )
                        return
                }</span>
        }
        /*         if plan.LockedAutoSnapshot.ValueBool() {
                err := vr.LockAutoSnapshot()
                if err != nil {
                        resp.Diagnostics.AddError(
                                "Error Locking Auto Snapshots",
                                "Could not lock auto snapshots, unexpected error: "+err.Error(),
                        )
                }
        } */
        <span class="cov0" title="0">volsResponse, err2 = spr.GetVolume("", volCreateResponse.ID, "", "", false)
        if err2 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting volume after mapping the sdcs",
                        "Could not get volume after mapping the sdcs, unexpected error: "+err2.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">vol = volsResponse[0]
        state := VolumeTerraformState(vol, plan)
        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Read refreshes the Terraform state with the latest data.
func (r *volumeResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) <span class="cov0" title="0">{
        // Get current state
        var state VolumeResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">spr, err1 := getStoragePoolInstance(r.client, state.StoragePoolID.ValueString(), state.StoragePoolName.ValueString(), state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString())
        if err1 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting storage pool",
                        "Could not get storage pool, unexpected err: "+err1.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">volsResponse, err2 := spr.GetVolume("", state.ID.ValueString(), "", "", false)
        if err2 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting volume",
                        "Could not get volume, unexpected error: "+err2.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">vol := volsResponse[0]
        state = VolumeTerraformState(vol, state)
        // Set refreshed state
        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Update updates the resource and sets the updated Terraform state on success.
func (r *volumeResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) <span class="cov0" title="0">{
        // Get plan values
        var plan VolumeResourceModel
        diags := req.Plan.Get(ctx, &amp;plan)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>

        // Get current state
        <span class="cov0" title="0">var state VolumeResourceModel
        diags = req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">VSIKB, _ := convertToKB(plan.CapacityUnit.ValueString(), plan.Size.ValueInt64())
        plan.VolumeSizeInKb = types.StringValue(strconv.FormatInt(VSIKB, 10))

        spr, err1 := getStoragePoolInstance(r.client, state.StoragePoolID.ValueString(), state.StoragePoolName.ValueString(), state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString())
        if err1 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting storage pool",
                        "Could not get storage pool, unexpected err: "+err1.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">volsplan, _ := spr.GetVolume("", state.ID.ValueString(), "", "", false)
        volresource := goscaleio.NewVolume(r.client)
        volresource.Volume = volsplan[0]

        // updating the name of volume if there is change in plan
        if plan.Name.ValueString() != state.Name.ValueString() </span><span class="cov0" title="0">{
                errRename := volresource.SetVolumeName(plan.Name.ValueString())
                if errRename != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error renaming the volume -&gt; "+plan.Name.ValueString()+" : "+state.Name.ValueString(),
                                "Could not rename the volume, unexpected error:"+errRename.Error(),
                        )
                        return
                }</span>
        }

        // updating the size of the volume if there is change in plan
        <span class="cov0" title="0">if plan.VolumeSizeInKb.ValueString() != state.VolumeSizeInKb.ValueString() </span><span class="cov0" title="0">{
                sizeInGb, _ := strconv.Atoi(strconv.FormatInt(VSIKB, 10))
                sizeInGb = sizeInGb / 1048576
                sizeInGB := strconv.FormatInt(int64(sizeInGb), 10)
                // sizeInGb = ((sizeInGb / 8) + 1) * 8
                // newSizeIn8Gb := strconv.FormatInt(int64(sizeInGb), 10)
                err3 := volresource.SetVolumeSize(sizeInGB)
                if err3 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error setting volume size -&gt; "+plan.VolumeSizeInKb.ValueString()+":"+state.VolumeSizeInKb.ValueString(),
                                "Could not set new volume size -&gt; "+sizeInGB+", unexpected err: "+err3.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov0" title="0">planSdcIds := []string{}
        stateSdcIds := []string{}
        diags = plan.MapSdcsID.ElementsAs(ctx, &amp;planSdcIds, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
        }</span>
        <span class="cov0" title="0">diags = state.MapSdcsID.ElementsAs(ctx, &amp;stateSdcIds, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
        }</span>
        <span class="cov0" title="0">mapSdcIds := Difference(planSdcIds, stateSdcIds)
        unmapSdcIds := Difference(stateSdcIds, planSdcIds)

        for _, msi := range mapSdcIds </span><span class="cov0" title="0">{
                pfmvsp := pftypes.MapVolumeSdcParam{
                        SdcID:                 msi,
                        AllowMultipleMappings: "true",
                }
                err3 := volresource.MapVolumeSdc(&amp;pfmvsp)
                if err3 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error Mapping Volume to SDCs",
                                "Could not map volume to scs with id: "+msi+", unexpected error: "+err3.Error(),
                        )
                        return
                }</span>
        }

        <span class="cov0" title="0">for _, usi := range unmapSdcIds </span><span class="cov0" title="0">{
                err4 := volresource.UnmapVolumeSdc(
                        &amp;pftypes.UnmapVolumeSdcParam{
                                SdcID: usi,
                        },
                )
                if err4 != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error Unmapping Volume to SDCs",
                                "Could not Unmap volume to scs with id: "+usi+", unexpected error: "+err4.Error(),
                        )
                        return
                }</span>
        }
        /*         if plan.LockedAutoSnapshot.ValueBool() &amp;&amp; !state.LockedAutoSnapshot.ValueBool() {
                           err := volresource.LockAutoSnapshot()
                           if err != nil {
                                   resp.Diagnostics.AddError(
                                           "Error Locking Auto Snapshots",
                                           "Could not lock auto snapshots, unexpected error: "+err.Error(),
                                   )
                           }
                   }
                   if !plan.LockedAutoSnapshot.ValueBool() &amp;&amp; state.LockedAutoSnapshot.ValueBool() {
                           err := volresource.UnlockAutoSnapshot()
                           if err != nil {
                                   resp.Diagnostics.AddError(
                                           "Error Unlocking Auto Snapshots",
                                           "Could not unlock auto snapshots, unexpected error: "+err.Error(),
                                   )
                           }
                   } */
        <span class="cov0" title="0">vols, _ := spr.GetVolume("", state.ID.ValueString(), "", "", false)
        state = VolumeTerraformState(vols[0], plan)
        // Set refreshed state
        diags = resp.State.Set(ctx, state)
        resp.Diagnostics.Append(diags...)
        if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
}

// Delete deletes the resource and removes the Terraform state on success.
func (r *volumeResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) <span class="cov0" title="0">{
        // Retrieve values from state
        var state VolumeResourceModel
        diags := req.State.Get(ctx, &amp;state)
        resp.Diagnostics.Append(diags...)
        spr, err1 := getStoragePoolInstance(r.client, state.StoragePoolID.ValueString(), state.StoragePoolName.ValueString(), state.ProtectionDomainID.ValueString(), state.ProtectionDomainName.ValueString())
        if err1 != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error getting storage pool",
                        "Could not get storage pool, unexpected err: "+err1.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">volsplan, _ := spr.GetVolume("", state.ID.ValueString(), "", "", false)
        volresource := goscaleio.NewVolume(r.client)
        volresource.Volume = volsplan[0]
        sdcsToUnmap := []string{}
        diags = state.MapSdcsID.ElementsAs(ctx, &amp;sdcsToUnmap, true)
        if diags.HasError() </span><span class="cov0" title="0">{
                resp.Diagnostics.Append(diags...)
        }</span>
        <span class="cov0" title="0">for _, stu := range sdcsToUnmap </span><span class="cov0" title="0">{
                err := volresource.UnmapVolumeSdc(
                        &amp;pftypes.UnmapVolumeSdcParam{
                                SdcID: stu,
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        resp.Diagnostics.AddError(
                                "Error Unmapping Volume to SDCs",
                                "Couldn't unmap volume to scs with id: "+stu+", unexpected error: "+err.Error(),
                        )
                        return
                }</span>
        }
        <span class="cov0" title="0">err := volresource.RemoveVolume("")
        if err != nil </span><span class="cov0" title="0">{
                resp.Diagnostics.AddError(
                        "Error Removing Volume",
                        "Couldn't remove volume "+err.Error(),
                )
                return
        }</span>
        <span class="cov0" title="0">if resp.Diagnostics.HasError() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">resp.State.RemoveResource(ctx)</span>
}

func (r *volumeResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) <span class="cov0" title="0">{
        // Retrieve import ID and save to id attribute
        resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package powerflex

import (
        "context"
        "errors"
        "fmt"
        "strconv"

        "github.com/dell/goscaleio"
        pftypes "github.com/dell/goscaleio/types/v1"
        "github.com/hashicorp/terraform-plugin-framework/attr"
        "github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
        "github.com/hashicorp/terraform-plugin-framework/types"
)

const (
        // MiKB to convert size in megabytes
        MiKB = 1024
        // GiKB to convert size in gigabytes
        GiKB = 1024 * MiKB
        // TiKB to convert size in terabytes
        TiKB = 1024 * GiKB
)

// covertToKB fucntion to convert size into kb
func convertToKB(capacityUnit string, size int64) (int64, error) <span class="cov8" title="1">{
        var valInKiB int64
        switch capacityUnit </span>{
        case "MB":<span class="cov0" title="0">
                valInKiB = size * MiKB</span>
        case "TB":<span class="cov0" title="0">
                valInKiB = size * TiKB</span>
        case "GB":<span class="cov8" title="1">
                valInKiB = size * GiKB</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("invalid capacity unit")</span>
        }
        <span class="cov8" title="1">return int64(valInKiB), nil</span>
}

// VolumeTerraformState function to convert goscaleio volume struct to terraform volume struct
func VolumeTerraformState(vol *pftypes.Volume, plan VolumeResourceModel) (state VolumeResourceModel) <span class="cov0" title="0">{
        state.ProtectionDomainID = plan.ProtectionDomainID
        state.ProtectionDomainName = plan.ProtectionDomainName
        state.StoragePoolName = plan.StoragePoolName
        state.Size = plan.Size
        state.CapacityUnit = plan.CapacityUnit
        state.MapSdcsID = plan.MapSdcsID
        state.LockedAutoSnapshot = types.BoolValue(vol.LockedAutoSnapshot)
        VSIKB, _ := convertToKB(plan.CapacityUnit.ValueString(), plan.Size.ValueInt64())
        state.VolumeSizeInKb = types.StringValue(strconv.FormatInt(VSIKB, 10))
        state.StoragePoolID = types.StringValue(vol.StoragePoolID)
        state.UseRmCache = types.BoolValue(vol.UseRmCache)
        state.MappingToAllSdcsEnabled = types.BoolValue(vol.MappingToAllSdcsEnabled)
        state.IsObfuscated = types.BoolValue(vol.IsObfuscated)
        state.VolumeType = types.StringValue(vol.VolumeType)
        state.ConsistencyGroupID = types.StringValue(vol.ConsistencyGroupID)
        state.VTreeID = types.StringValue(vol.VTreeID)
        state.AncestorVolumeID = types.StringValue(vol.AncestorVolumeID)
        state.MappedScsiInitiatorInfo = types.StringValue(vol.MappedScsiInitiatorInfo)
        state.SizeInKb = types.Int64Value(int64(vol.SizeInKb))
        state.CreationTime = types.Int64Value(int64(vol.CreationTime))
        state.Name = types.StringValue(vol.Name)
        state.ID = types.StringValue(vol.ID)
        state.DataLayout = types.StringValue(vol.DataLayout)
        state.NotGenuineSnapshot = types.BoolValue(vol.NotGenuineSnapshot)
        state.AccessModeLimit = types.StringValue(vol.AccessModeLimit)
        state.SecureSnapshotExpTime = types.Int64Value(int64(vol.SecureSnapshotExpTime))
        state.ManagedBy = types.StringValue(vol.ManagedBy)
        state.LockedAutoSnapshotMarkedForRemoval = types.BoolValue(vol.LockedAutoSnapshotMarkedForRemoval)
        state.CompressionMethod = types.StringValue(vol.CompressionMethod)
        state.TimeStampIsAccurate = types.BoolValue(vol.TimeStampIsAccurate)
        state.OriginalExpiryTime = types.Int64Value(int64(vol.OriginalExpiryTime))
        state.VolumeReplicationState = types.StringValue(vol.VolumeReplicationState)
        state.ReplicationJournalVolume = types.BoolValue(vol.ReplicationJournalVolume)
        state.ReplicationTimeStamp = types.Int64Value(int64(vol.ReplicationTimeStamp))

        linkAttrTypes := map[string]attr.Type{
                "rel":  types.StringType,
                "href": types.StringType,
        }
        mappedSdcInfoAttrTypes := map[string]attr.Type{
                "sdc_id":                   types.StringType,
                "sdc_ip":                   types.StringType,
                "limit_iops":               types.Int64Type,
                "limit_bw_in_mbps":         types.Int64Type,
                "sdc_name":                 types.StringType,
                "access_mode":              types.StringType,
                "is_direct_buffer_mapping": types.BoolType,
        }
        linkElemType := types.ObjectType{
                AttrTypes: linkAttrTypes,
        }
        mappedSdcInfoElemType := types.ObjectType{
                AttrTypes: mappedSdcInfoAttrTypes,
        }
        objectLinks := []attr.Value{}
        objectMappedSdcInfos := []attr.Value{}

        for _, link := range vol.Links </span><span class="cov0" title="0">{
                obj := map[string]attr.Value{
                        "rel":  types.StringValue(link.Rel),
                        "href": types.StringValue(link.HREF),
                }
                objVal, _ := types.ObjectValue(linkAttrTypes, obj)
                objectLinks = append(objectLinks, objVal)
        }</span>
        <span class="cov0" title="0">listVal, _ := types.ListValue(linkElemType, objectLinks)

        for _, msi := range vol.MappedSdcInfo </span><span class="cov0" title="0">{
                obj := map[string]attr.Value{
                        "sdc_id":                   types.StringValue(msi.SdcID),
                        "sdc_ip":                   types.StringValue(msi.SdcIP),
                        "limit_iops":               types.Int64Value(int64(msi.LimitIops)),
                        "limit_bw_in_mbps":         types.Int64Value(int64(msi.LimitBwInMbps)),
                        "sdc_name":                 types.StringValue(msi.SdcName),
                        "access_mode":              types.StringValue(msi.AccessMode),
                        "is_direct_buffer_mapping": types.BoolValue(msi.IsDirectBufferMapping),
                }
                objVal, _ := types.ObjectValue(mappedSdcInfoAttrTypes, obj)
                objectMappedSdcInfos = append(objectMappedSdcInfos, objVal)
        }</span>
        <span class="cov0" title="0">mappedSdcInfoVal, _ := types.ListValue(mappedSdcInfoElemType, objectMappedSdcInfos)
        state.Links = listVal
        state.MappedSdcInfo = mappedSdcInfoVal
        return state</span>
}

// getStoragePoolInstance function to get storage pool from storage pool id and protection domain id
func getStoragePoolInstance(c *goscaleio.Client, spID string, spName string, pdID string, pdName string) (*goscaleio.StoragePool, error) <span class="cov8" title="1">{
        getSystems, _ := c.GetSystems()
        sr := goscaleio.NewSystem(c)
        sr.System = getSystems[0]
        pdr := goscaleio.NewProtectionDomain(c)
        if pdID != "" </span><span class="cov8" title="1">{
                protectionDomain, err := sr.FindProtectionDomain(pdID, "", "")
                pdr.ProtectionDomain = protectionDomain
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> {
                protectionDomain, err := sr.FindProtectionDomain("", pdName, "")
                pdr.ProtectionDomain = protectionDomain
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">spr := goscaleio.NewStoragePool(c)
        if spID != "" </span><span class="cov0" title="0">{
                storagePool, err := pdr.FindStoragePool(spID, "", "")
                spr.StoragePool = storagePool
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov8" title="1"> {
                storagePool, err := pdr.FindStoragePool("", spName, "")
                spr.StoragePool = storagePool
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return spr, nil</span>
}

// Difference function to find the state difference b/w sdcs
func Difference(a, b []string) (diff []string) <span class="cov0" title="0">{
        m := make(map[string]bool)

        for _, item := range b </span><span class="cov0" title="0">{
                m[item] = true
        }</span>

        <span class="cov0" title="0">for _, item := range a </span><span class="cov0" title="0">{
                if _, ok := m[item]; !ok </span><span class="cov0" title="0">{
                        diff = append(diff, item)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// stringDefaultModifier is a plan modifier that sets a default value for a
// types.StringType attribute when it is not configured. The attribute must be
// marked as Optional and Computed. When setting the state during the resource
// Create, Read, or Update methods, this default value must also be included or
// the Terraform CLI will generate an error.
type stringDefaultModifier struct {
        Default string
}

// Description returns a plain text description of the validator's behavior, suitable for a practitioner to understand its impact.
func (m stringDefaultModifier) Description(ctx context.Context) string <span class="cov8" title="1">{
        return fmt.Sprintf("If value is not configured, defaults to %s", m.Default)
}</span>

// MarkdownDescription returns a markdown formatted description of the validator's behavior, suitable for a practitioner to understand its impact.
func (m stringDefaultModifier) MarkdownDescription(ctx context.Context) string <span class="cov0" title="0">{
        return fmt.Sprintf("If value is not configured, defaults to `%s`", m.Default)
}</span>

// PlanModifyString runs the logic of the plan modifier.
// Access to the configuration, plan, and state is available in `req`, while
// `resp` contains fields for updating the planned value, triggering resource
// replacement, and returning diagnostics.
func (m stringDefaultModifier) PlanModifyString(ctx context.Context, req planmodifier.StringRequest, resp *planmodifier.StringResponse) <span class="cov8" title="1">{
        // If the value is unknown or known, do not set default value.
        // if !req.PlanValue.IsNull() {
        //         return
        // }

        resp.PlanValue = types.StringValue(m.Default)
}</span>

func stringDefault(defaultValue string) planmodifier.String <span class="cov8" title="1">{
        return stringDefaultModifier{
                Default: defaultValue,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
